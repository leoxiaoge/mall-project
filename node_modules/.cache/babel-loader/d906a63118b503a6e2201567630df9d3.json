{"remainingRequest":"/Users/lee/Desktop/github/mall-project/node_modules/babel-loader/lib/index.js!/Users/lee/Desktop/github/mall-project/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader/index.js??ref--12-2!/Users/lee/Desktop/github/mall-project/src/components/mescroll-uni/mescroll-uni.js","dependencies":[{"path":"/Users/lee/Desktop/github/mall-project/src/components/mescroll-uni/mescroll-uni.js","mtime":1562003769862},{"path":"/Users/lee/Desktop/github/mall-project/node_modules/cache-loader/dist/cjs.js","mtime":1554990705312},{"path":"/Users/lee/Desktop/github/mall-project/node_modules/babel-loader/lib/index.js","mtime":1560261191357},{"path":"/Users/lee/Desktop/github/mall-project/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader/index.js","mtime":1561751947145}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = MeScroll;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* mescroll\n * version 1.1.0\n * 2019-07-01 lichubiao\n */\nfunction MeScroll(options) {\n  var me = this;\n  me.version = '1.1.0'; // mescroll版本号\n\n  me.options = options || {}; // 配置\n\n  me.isDownScrolling = false; // 是否在执行下拉刷新的回调\n\n  me.isUpScrolling = false; // 是否在执行上拉加载的回调\n\n  var hasDownCallback = me.options.down && me.options.down.callback; // 是否配置了down的callback\n  // 初始化下拉刷新\n\n  me.initDownScroll(); // 初始化上拉加载,则初始化\n\n  me.initUpScroll(); // 自动加载\n\n  setTimeout(function () {\n    // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n    // 自动触发下拉刷新 (只有配置了down的callback才自动触发下拉刷新)\n    if (me.optDown.use && me.optDown.auto && hasDownCallback) {\n      if (me.optDown.autoShowLoading) {\n        me.triggerDownScroll(); // 显示下拉进度,执行下拉回调\n      } else {\n        me.optDown.callback && me.optDown.callback(me); // 不显示下拉进度,直接执行下拉回调\n      }\n    } // 自动触发上拉加载\n\n\n    me.optUp.use && me.optUp.auto && !me.isUpAutoLoad && me.triggerUpScroll();\n  }, 30); // 需让me.optDown.inited和me.optUp.inited先执行\n}\n/* 配置参数:下拉刷新 */\n\n\nMeScroll.prototype.extendDownScroll = function (optDown) {\n  // 下拉刷新的配置\n  MeScroll.extend(optDown, {\n    use: true,\n    // 是否启用下拉刷新; 默认true\n    auto: true,\n    // 是否在初始化完毕之后自动执行下拉刷新的回调; 默认true\n    autoShowLoading: false,\n    // 如果设置auto=true(在初始化完毕之后自动执行下拉刷新的回调),那么是否显示下拉刷新的进度; 默认false\n    isLock: false,\n    // 是否锁定下拉刷新,默认false;\n    isBoth: true,\n    // 下拉刷新时,如果滑动到列表底部是否可以同时触发上拉加载;默认true,两者可同时触发;\n    offset: 80,\n    // 在列表顶部,下拉大于80px,松手即可触发下拉刷新的回调\n    fps: 40,\n    // 下拉节流 (值越大每秒刷新频率越高)\n    inOffsetRate: 1,\n    // 在列表顶部,下拉的距离小于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\n    outOffsetRate: 0.2,\n    // 在列表顶部,下拉的距离大于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\n    bottomOffset: 20,\n    // 当手指touchmove位置在距离body底部20px范围内的时候结束上拉刷新,避免Webview嵌套导致touchend事件不执行\n    minAngle: 45,\n    // 向下滑动最少偏移的角度,取值区间  [0,90];默认45度,即向下滑动的角度大于45度则触发下拉;而小于45度,将不触发下拉,避免与左右滑动的轮播等组件冲突;\n    textInOffset: '下拉刷新',\n    // 下拉的距离在offset范围内的提示文本\n    textOutOffset: '释放更新',\n    // 下拉的距离大于offset范围的提示文本\n    textLoading: '加载中 ...',\n    // 加载中的提示文本\n    inited: null,\n    // 下拉刷新初始化完毕的回调\n    inOffset: null,\n    // 下拉的距离进入offset范围内那一刻的回调\n    outOffset: null,\n    // 下拉的距离大于offset那一刻的回调\n    onMoving: null,\n    // 下拉过程中的回调,滑动过程一直在执行; rate下拉区域当前高度与指定距离的比值(inOffset: rate<1; outOffset: rate>=1); downHight当前下拉区域的高度\n    beforeLoading: null,\n    // 准备触发下拉刷新的回调: 如果return true,将不触发showLoading和callback回调; 常用来完全自定义下拉刷新, 参考案例【淘宝 v6.8.0】\n    showLoading: null,\n    // 显示下拉刷新进度的回调\n    afterLoading: null,\n    // 准备结束下拉的回调. 返回结束下拉的延时执行时间,默认0ms; 常用于结束下拉之前再显示另外一小段动画,才去隐藏下拉刷新的场景, 参考案例【dotJump】\n    endDownScroll: null,\n    // 结束下拉刷新的回调\n    callback: function callback(mescroll) {\n      // 下拉刷新的回调;默认重置上拉加载列表为第一页\n      mescroll.resetUpScroll();\n    }\n  });\n};\n/* 配置参数:上拉加载 */\n\n\nMeScroll.prototype.extendUpScroll = function (optUp) {\n  // 上拉加载的配置\n  MeScroll.extend(optUp, {\n    use: true,\n    // 是否启用上拉加载; 默认true\n    auto: true,\n    // 是否在初始化完毕之后自动执行上拉加载的回调; 默认true\n    isLock: false,\n    // 是否锁定上拉加载,默认false;\n    isBoth: true,\n    // 上拉加载时,如果滑动到列表顶部是否可以同时触发下拉刷新;默认true,两者可同时触发;\n    callback: null,\n    // 上拉加载的回调;function(page,mescroll){ }\n    page: {\n      num: 0,\n      // 当前页码,默认0,回调之前会加1,即callback(page)会从1开始\n      size: 10,\n      // 每页数据的数量\n      time: null // 加载第一页数据服务器返回的时间; 防止用户翻页时,后台新增了数据从而导致下一页数据重复;\n\n    },\n    fps: 40,\n    // 上拉节流 (值越大每秒刷新频率越高)\n    noMoreSize: 5,\n    // 如果列表已无数据,可设置列表的总数量要大于等于5条才显示无更多数据;避免列表数据过少(比如只有一条数据),显示无更多数据会不好看\n    offset: 80,\n    // 距底部多远时,触发upCallback\n    textLoading: '加载中 ...',\n    // 加载中的提示文本\n    textNoMore: '-- END --',\n    // 没有更多数据的提示文本\n    inited: null,\n    // 初始化完毕的回调\n    showLoading: null,\n    // 显示加载中的回调\n    showNoMore: null,\n    // 显示无更多数据的回调\n    hideUpScroll: null,\n    // 隐藏上拉加载的回调\n    toTop: {\n      // 回到顶部按钮,需配置src才显示\n      src: null,\n      // 图片路径,默认null (建议写成网络图,不必考虑相对路径)\n      offset: 1000,\n      // 列表滚动多少距离才显示回到顶部按钮,默认1000\n      duration: 300,\n      // 回到顶部的动画时长,默认300ms\n      btnClick: null,\n      // 点击按钮的回调\n      onShow: null // 是否显示的回调\n\n    },\n    empty: {\n      use: true,\n      // 是否显示空布局\n      icon: null,\n      // 图标路径\n      tip: '~ 暂无相关数据 ~',\n      // 提示\n      btnText: '',\n      // 按钮\n      btnClick: null,\n      // 点击按钮的回调\n      onShow: null // 是否显示的回调\n\n    },\n    onScroll: false // 是否监听滚动事件\n\n  });\n};\n/* 配置参数 */\n\n\nMeScroll.extend = function (userOption, defaultOption) {\n  if (!userOption) return defaultOption;\n\n  for (var key in defaultOption) {\n    if (userOption[key] == null) {\n      userOption[key] = defaultOption[key];\n    } else if (_typeof(userOption[key]) === 'object') {\n      MeScroll.extend(userOption[key], defaultOption[key]); // 深度匹配\n    }\n  }\n\n  return userOption;\n};\n/* -------初始化下拉刷新------- */\n\n\nMeScroll.prototype.initDownScroll = function () {\n  var me = this; // 配置参数\n\n  me.optDown = me.options.down || {};\n  me.extendDownScroll(me.optDown);\n  me.downHight = 0; // 下拉区域的高度\n  // 在页面中加入下拉布局\n\n  if (me.optDown.use && me.optDown.inited) {\n    // 初始化完毕的回调\n    setTimeout(function () {\n      // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n      me.optDown.inited(me);\n    }, 0);\n  }\n};\n/* 列表touchstart事件 */\n\n\nMeScroll.prototype.touchstartEvent = function (e) {\n  if (!this.optDown.use) return;\n  var me = this;\n  me.startPoint = me.getPoint(e); // 记录起点\n\n  me.lastPoint = me.startPoint; // 重置上次move的点\n\n  me.maxTouchmoveY = me.getBodyHeight() - me.optDown.bottomOffset; // 手指触摸的最大范围(写在touchstart避免body获取高度为0的情况)\n\n  me.inTouchend = false; // 标记不是touchend\n};\n/* 列表touchmove事件 */\n\n\nMeScroll.prototype.touchmoveEvent = function (e) {\n  if (!this.optDown.use) return;\n  if (!this.startPoint) return;\n  var me = this; // 节流\n\n  var t = new Date().getTime();\n\n  if (me.moveTime && t - me.moveTime < me.moveTimeDiff) {\n    // 小于节流时间,则不处理\n    return;\n  } else {\n    me.moveTime = t;\n    me.moveTimeDiff = 1000 / me.optDown.fps;\n  }\n\n  var scrollTop = me.getScrollTop(); // 当前滚动条的距离\n\n  var curPoint = me.getPoint(e); // 当前点\n\n  var moveY = curPoint.y - me.startPoint.y; // 和起点比,移动的距离,大于0向下拉,小于0向上拉\n  // (向下拉&&在顶部)\n\n  if (moveY > 0 && scrollTop <= 0) {\n    // 可下拉的条件\n    if (me.optDown.use && !me.inTouchend && !me.isDownScrolling && !me.optDown.isLock && (!me.isUpScrolling || me.isUpScrolling && me.optUp.isBoth)) {\n      // 下拉的角度是否在配置的范围内\n      var x = Math.abs(me.lastPoint.x - curPoint.x);\n      var y = Math.abs(me.lastPoint.y - curPoint.y);\n      var z = Math.sqrt(x * x + y * y);\n\n      if (z !== 0) {\n        var angle = Math.asin(y / z) / Math.PI * 180; // 两点之间的角度,区间 [0,90]\n\n        if (angle < me.optDown.minAngle) return; // 如果小于配置的角度,则不往下执行下拉刷新\n      } // 如果手指的位置超过配置的距离,则提前结束下拉,避免Webview嵌套导致touchend无法触发\n\n\n      if (me.maxTouchmoveY > 0 && curPoint.y >= me.maxTouchmoveY) {\n        me.inTouchend = true; // 标记执行touchend\n\n        me.touchendEvent(); // 提前触发touchend\n\n        return;\n      }\n\n      me.preventDefault(e); // 阻止默认事件\n\n      var diff = curPoint.y - me.lastPoint.y; // 和上次比,移动的距离 (大于0向下,小于0向上)\n      // 下拉距离  < 指定距离\n\n      if (me.downHight < me.optDown.offset) {\n        if (me.movetype !== 1) {\n          me.movetype = 1; // 加入标记,保证只执行一次\n\n          me.optDown.inOffset && me.optDown.inOffset(me); // 进入指定距离范围内那一刻的回调,只执行一次\n\n          me.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\n        }\n\n        me.downHight += diff * me.optDown.inOffsetRate; // 越往下,高度变化越小\n        // 指定距离  <= 下拉距离\n      } else {\n        if (me.movetype !== 2) {\n          me.movetype = 2; // 加入标记,保证只执行一次\n\n          me.optDown.outOffset && me.optDown.outOffset(me); // 下拉超过指定距离那一刻的回调,只执行一次\n\n          me.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\n        }\n\n        if (diff > 0) {\n          // 向下拉\n          me.downHight += Math.round(diff * me.optDown.outOffsetRate); // 越往下,高度变化越小\n        } else {\n          // 向上收\n          me.downHight += diff; // 向上收回高度,则向上滑多少收多少高度\n        }\n      }\n\n      var rate = me.downHight / me.optDown.offset; // 下拉区域当前高度与指定距离的比值\n\n      me.optDown.onMoving && me.optDown.onMoving(me, rate, me.downHight); // 下拉过程中的回调,一直在执行\n    }\n  }\n\n  me.lastPoint = curPoint; // 记录本次移动的点\n};\n/* 列表touchend事件 */\n\n\nMeScroll.prototype.touchendEvent = function (e) {\n  if (!this.optDown.use) return; // 如果下拉区域高度已改变,则需重置回来\n\n  if (this.isMoveDown) {\n    var me = this;\n\n    if (me.downHight >= me.optDown.offset) {\n      // 符合触发刷新的条件\n      me.triggerDownScroll();\n    } else {\n      // 不符合的话 则重置\n      me.downHight = 0;\n      me.optDown.endDownScroll && me.optDown.endDownScroll(me);\n    }\n\n    me.movetype = 0;\n    me.isMoveDown = false;\n  }\n};\n/* 根据点击滑动事件获取第一个手指的坐标 */\n\n\nMeScroll.prototype.getPoint = function (e) {\n  return {\n    x: e.touches ? e.touches[0].pageX : e.clientX,\n    y: e.touches ? e.touches[0].pageY : e.clientY\n  };\n};\n/* 触发下拉刷新 */\n\n\nMeScroll.prototype.triggerDownScroll = function () {\n  if (this.optDown.beforeLoading && this.optDown.beforeLoading(this)) {//return true则处于完全自定义状态\n  } else {\n    this.showDownScroll(); // 下拉刷新中...\n\n    this.optDown.callback && this.optDown.callback(this); // 执行回调,联网加载数据\n  }\n};\n/* 显示下拉进度布局 */\n\n\nMeScroll.prototype.showDownScroll = function () {\n  this.isDownScrolling = true; // 标记下拉中\n\n  this.downHight = this.optDown.offset; // 更新下拉区域高度\n\n  this.optDown.showLoading(this, this.downHight); // 下拉刷新中...\n};\n/* 结束下拉刷新 */\n\n\nMeScroll.prototype.endDownScroll = function () {\n  var me = this; // 结束下拉刷新的方法\n\n  var endScroll = function endScroll() {\n    me.downHight = 0;\n    me.isDownScrolling = false;\n    me.optDown.endDownScroll && me.optDown.endDownScroll(me);\n  }; // 结束下拉刷新时的回调\n\n\n  var delay = 0;\n  if (me.optDown.afterLoading) delay = me.optDown.afterLoading(me); // 结束下拉刷新的延时,单位ms\n\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(endScroll, delay);\n  } else {\n    endScroll();\n  }\n};\n/* 锁定下拉刷新:isLock=ture,null锁定;isLock=false解锁 */\n\n\nMeScroll.prototype.lockDownScroll = function (isLock) {\n  if (isLock == null) isLock = true;\n  this.optDown.isLock = isLock;\n};\n/* -------初始化上拉加载------- */\n\n\nMeScroll.prototype.initUpScroll = function () {\n  var me = this; // 配置参数\n\n  me.optUp = me.options.up || {\n    use: false\n  };\n  me.extendUpScroll(me.optUp);\n  if (me.optUp.use === false) return; // 配置不使用上拉加载时,则不初始化上拉布局\n\n  me.optUp.hasNext = true; // 如果使用上拉,则默认有下一页\n\n  me.optUp.empty.btnText = me.optUp.empty.btnText || me.optUp.empty.btntext; // 兼容以前版本的btntext\n  // 初始化完毕的回调\n\n  if (me.optUp.inited) {\n    setTimeout(function () {\n      // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n      me.optUp.inited(me);\n    }, 0);\n  }\n};\n/*滚动到底部的事件*/\n\n\nMeScroll.prototype.onReachBottom = function () {\n  console.warn('当前版本无需再调用mescroll.onReachBottom()'); // 兼容1.0.3以下版本,防止报错\n};\n\nMeScroll.prototype.scrolltolower = function () {\n  if (!this.isUpScrolling && (!this.isDownScrolling || this.isDownScrolling && this.optDown.isBoth)) {\n    if (!this.optUp.isLock && this.optUp.hasNext) {\n      this.triggerUpScroll();\n    }\n  }\n};\n/*列表滚动事件*/\n\n\nMeScroll.prototype.onPageScroll = function () {\n  console.warn('当前版本无需再调用mescroll.onPageScroll(e)'); // 兼容1.0.3以下版本,防止报错\n};\n\nMeScroll.prototype.scroll = function (e, onScroll) {\n  // 节流\n  var t = new Date().getTime();\n\n  if (this.scrollTime && t - this.scrollTime < this.scrollTimeDiff) {\n    // 小于节流时间,则不处理\n    return;\n  } else {\n    this.scrollTime = t;\n    this.scrollTimeDiff = 1000 / this.optUp.fps;\n  }\n\n  var me = this;\n  var scrollTop = e.scrollTop; // 顶部按钮的显示隐藏\n\n  if (scrollTop > 0 && me.optUp.toTop.src) {\n    if (scrollTop >= me.optUp.toTop.offset) {\n      me.showTopBtn();\n    } else {\n      me.hideTopBtn();\n    }\n  } // 滑动监听\n\n\n  if (me.optUp.onScroll && onScroll) {\n    // 向上滑还是向下滑动\n    if (me.preScrollY == null) me.preScrollY = 0;\n    me.isScrollUp = scrollTop - me.preScrollY > 0;\n    me.preScrollY = scrollTop; // 滚动回调\n\n    onScroll(me, scrollTop, me.isScrollUp);\n  }\n\n  me.setScrollTop(scrollTop);\n};\n/* 触发上拉加载 */\n\n\nMeScroll.prototype.triggerUpScroll = function () {\n  if (this.optUp.callback && !this.isUpScrolling) {\n    this.showUpScroll(); // 上拉加载中...\n\n    this.optUp.page.num++; // 预先加一页,如果失败则减回\n\n    this.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\n\n    this.num = this.optUp.page.num; // 把最新的页数赋值在mescroll上,避免对page的影响\n\n    this.size = this.optUp.page.size; // 把最新的页码赋值在mescroll上,避免对page的影响\n\n    this.time = this.optUp.page.time; // 把最新的页码赋值在mescroll上,避免对page的影响\n\n    this.optUp.callback(this); // 执行回调,联网加载数据\n  }\n};\n/* 显示上拉加载中 */\n\n\nMeScroll.prototype.showUpScroll = function () {\n  this.isUpScrolling = true; // 标记上拉加载中\n\n  this.optUp.showLoading && this.optUp.showLoading(this); // 回调\n};\n/* 显示上拉无更多数据 */\n\n\nMeScroll.prototype.showNoMore = function () {\n  this.optUp.hasNext = false; // 标记无更多数据\n\n  this.optUp.showNoMore && this.optUp.showNoMore(this); // 回调\n};\n/* 隐藏上拉区域**/\n\n\nMeScroll.prototype.hideUpScroll = function () {\n  this.optUp.hideUpScroll && this.optUp.hideUpScroll(this); // 回调\n};\n/* 结束上拉加载 */\n\n\nMeScroll.prototype.endUpScroll = function (isShowNoMore) {\n  if (isShowNoMore != null) {\n    // isShowNoMore=null,不处理下拉状态,下拉刷新的时候调用\n    if (isShowNoMore) {\n      this.showNoMore(); // isShowNoMore=true,显示无更多数据\n    } else {\n      this.hideUpScroll(); // isShowNoMore=false,隐藏上拉加载\n    }\n  }\n\n  this.isUpScrolling = false; // 标记结束上拉加载\n};\n/* 重置上拉加载列表为第一页\n *isShowLoading 是否显示进度布局;\n * 1.默认null,不传参,则显示上拉加载的进度布局\n * 2.传参true, 则显示下拉刷新的进度布局\n * 3.传参false,则不显示上拉和下拉的进度 (常用于静默更新列表数据)\n */\n\n\nMeScroll.prototype.resetUpScroll = function (isShowLoading) {\n  if (this.optUp && this.optUp.use) {\n    var page = this.optUp.page;\n    this.prePageNum = page.num; // 缓存重置前的页码,加载失败可退回\n\n    this.prePageTime = page.time; // 缓存重置前的时间,加载失败可退回\n\n    page.num = 1; // 重置为第一页\n\n    page.time = null; // 重置时间为空\n\n    if (!this.isDownScrolling && isShowLoading !== false) {\n      // 如果不是下拉刷新触发的resetUpScroll并且不配置列表静默更新,则显示进度;\n      if (isShowLoading == null) {\n        this.removeEmpty(); // 移除空布局\n\n        this.showUpScroll(); // 不传参,默认显示上拉加载的进度布局\n      } else {\n        this.showDownScroll(); // 传true,显示下拉刷新的进度布局,不清空列表\n      }\n    }\n\n    this.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\n\n    this.num = page.num; // 把最新的页数赋值在mescroll上,避免对page的影响\n\n    this.size = page.size; // 把最新的页码赋值在mescroll上,避免对page的影响\n\n    this.time = page.time; // 把最新的页码赋值在mescroll上,避免对page的影响\n\n    this.optUp.callback && this.optUp.callback(this); // 执行上拉回调\n  }\n};\n/* 设置page.num的值 */\n\n\nMeScroll.prototype.setPageNum = function (num) {\n  this.optUp.page.num = num - 1;\n};\n/* 设置page.size的值 */\n\n\nMeScroll.prototype.setPageSize = function (size) {\n  this.optUp.page.size = size;\n};\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据量(必传)\n * totalPage: 总页数(必传)\n * systime: 服务器时间 (可空)\n */\n\n\nMeScroll.prototype.endByPage = function (dataSize, totalPage, systime) {\n  var hasNext;\n  if (this.optUp.use && totalPage != null) hasNext = this.optUp.page.num < totalPage; // 是否还有下一页\n\n  this.endSuccess(dataSize, hasNext, systime);\n};\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据量(必传)\n * totalSize: 列表所有数据总数量(必传)\n * systime: 服务器时间 (可空)\n */\n\n\nMeScroll.prototype.endBySize = function (dataSize, totalSize, systime) {\n  var hasNext;\n\n  if (this.optUp.use && totalSize != null) {\n    var loadSize = (this.optUp.page.num - 1) * this.optUp.page.size + dataSize; // 已加载的数据总数\n\n    hasNext = loadSize < totalSize; // 是否还有下一页\n  }\n\n  this.endSuccess(dataSize, hasNext, systime);\n};\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据个数(不是所有页的数据总和),用于上拉加载判断是否还有下一页.如果不传,则会判断还有下一页\n * hasNext: 是否还有下一页,布尔类型;用来解决这个小问题:比如列表共有20条数据,每页加载10条,共2页.如果只根据dataSize判断,则需翻到第三页才会知道无更多数据,如果传了hasNext,则翻到第二页即可显示无更多数据.\n * systime: 服务器时间(可空);用来解决这个小问题:当准备翻下一页时,数据库新增了几条记录,此时翻下一页,前面的几条数据会和上一页的重复;这里传入了systime,那么upCallback的page.time就会有值,把page.time传给服务器,让后台过滤新加入的那几条记录\n */\n\n\nMeScroll.prototype.endSuccess = function (dataSize, hasNext, systime) {\n  var me = this; // 结束下拉刷新\n\n  if (me.isDownScrolling) me.endDownScroll(); // 结束上拉加载\n\n  if (me.optUp.use) {\n    var isShowNoMore; // 是否已无更多数据\n\n    if (dataSize != null) {\n      var pageNum = me.optUp.page.num; // 当前页码\n\n      var pageSize = me.optUp.page.size; // 每页长度\n      // 如果是第一页\n\n      if (pageNum === 1) {\n        if (systime) me.optUp.page.time = systime; // 设置加载列表数据第一页的时间\n      }\n\n      if (dataSize < pageSize || hasNext === false) {\n        // 返回的数据不满一页时,则说明已无更多数据\n        me.optUp.hasNext = false;\n\n        if (dataSize === 0 && pageNum === 1) {\n          // 如果第一页无任何数据且配置了空布局\n          isShowNoMore = false;\n          me.showEmpty();\n        } else {\n          // 总列表数少于配置的数量,则不显示无更多数据\n          var allDataSize = (pageNum - 1) * pageSize + dataSize;\n\n          if (allDataSize < me.optUp.noMoreSize) {\n            isShowNoMore = false;\n          } else {\n            isShowNoMore = true;\n          }\n\n          me.removeEmpty(); // 移除空布局\n        }\n      } else {\n        // 还有下一页\n        isShowNoMore = false;\n        me.optUp.hasNext = true;\n        me.removeEmpty(); // 移除空布局\n      }\n    } // 隐藏上拉\n\n\n    me.endUpScroll(isShowNoMore);\n  }\n};\n/* 回调失败,结束下拉刷新和上拉加载 */\n\n\nMeScroll.prototype.endErr = function () {\n  // 结束下拉,回调失败重置回原来的页码和时间\n  if (this.isDownScrolling) {\n    var page = this.optUp.page;\n\n    if (page && this.prePageNum) {\n      page.num = this.prePageNum;\n      page.time = this.prePageTime;\n    }\n\n    this.endDownScroll();\n  } // 结束上拉,回调失败重置回原来的页码\n\n\n  if (this.isUpScrolling) {\n    this.optUp.page.num--;\n    this.endUpScroll(false);\n    this.scrollTo(this.getScrollTop() - 1, 0); // 往上回滚1px,使其能够再次触发scrolltolower\n  }\n};\n/* 显示空布局 */\n\n\nMeScroll.prototype.showEmpty = function () {\n  this.optUp.empty.use && this.optUp.empty.onShow && this.optUp.empty.onShow(true);\n};\n/* 移除空布局 */\n\n\nMeScroll.prototype.removeEmpty = function () {\n  this.optUp.empty.onShow && this.optUp.empty.onShow(false);\n};\n/* 显示回到顶部的按钮 */\n\n\nMeScroll.prototype.showTopBtn = function () {\n  if (this.optUp.toTop.src && !this.topBtnShow) {\n    this.topBtnShow = true;\n    this.optUp.toTop.onShow && this.optUp.toTop.onShow(true);\n  }\n};\n/* 隐藏回到顶部的按钮 */\n\n\nMeScroll.prototype.hideTopBtn = function () {\n  if (this.optUp.toTop.src && this.topBtnShow) {\n    this.topBtnShow = false;\n    this.optUp.toTop.onShow && this.optUp.toTop.onShow(false);\n  }\n};\n/* 获取滚动条的位置 */\n\n\nMeScroll.prototype.getScrollTop = function () {\n  return this.scrollTop || 0;\n};\n/* 记录滚动条的位置 */\n\n\nMeScroll.prototype.setScrollTop = function (y) {\n  this.scrollTop = y;\n};\n/* 滚动到指定位置 */\n\n\nMeScroll.prototype.scrollTo = function (y, t) {\n  this.myScrollTo && this.myScrollTo(y, t); // scrollview需自定义回到顶部方法\n};\n/* 自定义scrollTo */\n\n\nMeScroll.prototype.resetScrollTo = function (myScrollTo) {\n  this.myScrollTo = myScrollTo;\n};\n/* 计步器\n star: 开始值\n end: 结束值\n callback(step,timer): 回调step值,计步器timer,可自行通过window.clearInterval(timer)结束计步器;\n t: 计步时长,传0则直接回调end值;不传则默认300ms\n rate: 周期;不传则默认30ms计步一次\n * */\n\n\nMeScroll.prototype.getStep = function (star, end, callback, t, rate) {\n  var diff = end - star; // 差值\n\n  if (t === 0 || diff === 0) {\n    callback && callback(end);\n    return;\n  }\n\n  t = t || 300; // 时长 300ms\n\n  rate = rate || 30; // 周期 30ms\n\n  var count = t / rate; // 次数\n\n  var step = diff / count; // 步长\n\n  var i = 0; // 计数\n\n  var timer = setInterval(function () {\n    if (i < count - 1) {\n      star += step;\n      callback && callback(star, timer);\n      i++;\n    } else {\n      callback && callback(end, timer); // 最后一次直接设置end,避免计算误差\n\n      clearInterval(timer);\n    }\n  }, rate);\n};\n/* body的高度 */\n\n\nMeScroll.prototype.getBodyHeight = function () {\n  return this.bodyHeight || 0;\n};\n\nMeScroll.prototype.setBodyHeight = function (h) {\n  this.bodyHeight = h;\n};\n/* 阻止浏览器默认滚动事件 */\n\n\nMeScroll.prototype.preventDefault = function (e) {\n  // cancelable:是否可以被禁用; defaultPrevented:是否已经被禁用\n  // if (e && e.cancelable && !e.defaultPrevented) e.preventDefault()\n  // 只能通过配置pages.json的style.app-plus.bounce为\"none\"来禁止app的bounce\n  e && e.preventDefault();\n};",{"version":3,"sources":["/Users/lee/Desktop/github/mall-project/src/components/mescroll-uni/mescroll-uni.js"],"names":["MeScroll","options","me","version","isDownScrolling","isUpScrolling","hasDownCallback","down","callback","initDownScroll","initUpScroll","setTimeout","optDown","use","auto","autoShowLoading","triggerDownScroll","optUp","isUpAutoLoad","triggerUpScroll","prototype","extendDownScroll","extend","isLock","isBoth","offset","fps","inOffsetRate","outOffsetRate","bottomOffset","minAngle","textInOffset","textOutOffset","textLoading","inited","inOffset","outOffset","onMoving","beforeLoading","showLoading","afterLoading","endDownScroll","mescroll","resetUpScroll","extendUpScroll","page","num","size","time","noMoreSize","textNoMore","showNoMore","hideUpScroll","toTop","src","duration","btnClick","onShow","empty","icon","tip","btnText","onScroll","userOption","defaultOption","key","downHight","touchstartEvent","e","startPoint","getPoint","lastPoint","maxTouchmoveY","getBodyHeight","inTouchend","touchmoveEvent","t","Date","getTime","moveTime","moveTimeDiff","scrollTop","getScrollTop","curPoint","moveY","y","x","Math","abs","z","sqrt","angle","asin","PI","touchendEvent","preventDefault","diff","movetype","isMoveDown","round","rate","touches","pageX","clientX","pageY","clientY","showDownScroll","endScroll","delay","lockDownScroll","up","hasNext","btntext","onReachBottom","console","warn","scrolltolower","onPageScroll","scroll","scrollTime","scrollTimeDiff","showTopBtn","hideTopBtn","preScrollY","isScrollUp","setScrollTop","showUpScroll","endUpScroll","isShowNoMore","isShowLoading","prePageNum","prePageTime","removeEmpty","setPageNum","setPageSize","endByPage","dataSize","totalPage","systime","endSuccess","endBySize","totalSize","loadSize","pageNum","pageSize","showEmpty","allDataSize","endErr","scrollTo","topBtnShow","myScrollTo","resetScrollTo","getStep","star","end","count","step","i","timer","setInterval","clearInterval","bodyHeight","setBodyHeight","h"],"mappings":";;;;;;;;;AAAA;;;;AAKe,SAASA,QAAT,CAAkBC,OAAlB,EAA2B;AACzC,MAAIC,EAAE,GAAG,IAAT;AACAA,EAAAA,EAAE,CAACC,OAAH,GAAa,OAAb,CAFyC,CAEnB;;AACtBD,EAAAA,EAAE,CAACD,OAAH,GAAaA,OAAO,IAAI,EAAxB,CAHyC,CAGb;;AAE5BC,EAAAA,EAAE,CAACE,eAAH,GAAqB,KAArB,CALyC,CAKb;;AAC5BF,EAAAA,EAAE,CAACG,aAAH,GAAmB,KAAnB,CANyC,CAMf;;AAC1B,MAAIC,eAAe,GAAGJ,EAAE,CAACD,OAAH,CAAWM,IAAX,IAAmBL,EAAE,CAACD,OAAH,CAAWM,IAAX,CAAgBC,QAAzD,CAPyC,CAO0B;AAEnE;;AACAN,EAAAA,EAAE,CAACO,cAAH,GAVyC,CAWzC;;AACAP,EAAAA,EAAE,CAACQ,YAAH,GAZyC,CAczC;;AACAC,EAAAA,UAAU,CAAC,YAAW;AAAE;AACvB;AACA,QAAIT,EAAE,CAACU,OAAH,CAAWC,GAAX,IAAkBX,EAAE,CAACU,OAAH,CAAWE,IAA7B,IAAqCR,eAAzC,EAA0D;AACzD,UAAIJ,EAAE,CAACU,OAAH,CAAWG,eAAf,EAAgC;AAC/Bb,QAAAA,EAAE,CAACc,iBAAH,GAD+B,CACP;AACxB,OAFD,MAEO;AACNd,QAAAA,EAAE,CAACU,OAAH,CAAWJ,QAAX,IAAuBN,EAAE,CAACU,OAAH,CAAWJ,QAAX,CAAoBN,EAApB,CAAvB,CADM,CAC0C;AAChD;AACD,KARoB,CASrB;;;AACAA,IAAAA,EAAE,CAACe,KAAH,CAASJ,GAAT,IAAgBX,EAAE,CAACe,KAAH,CAASH,IAAzB,IAAiC,CAACZ,EAAE,CAACgB,YAArC,IAAqDhB,EAAE,CAACiB,eAAH,EAArD;AACA,GAXS,EAWP,EAXO,CAAV,CAfyC,CA0BjC;AACR;AAED;;;AACAnB,QAAQ,CAACoB,SAAT,CAAmBC,gBAAnB,GAAsC,UAAST,OAAT,EAAkB;AACvD;AACAZ,EAAAA,QAAQ,CAACsB,MAAT,CAAgBV,OAAhB,EAAyB;AACxBC,IAAAA,GAAG,EAAE,IADmB;AACb;AACXC,IAAAA,IAAI,EAAE,IAFkB;AAEZ;AACZC,IAAAA,eAAe,EAAE,KAHO;AAGA;AACxBQ,IAAAA,MAAM,EAAE,KAJgB;AAIT;AACfC,IAAAA,MAAM,EAAE,IALgB;AAKV;AACdC,IAAAA,MAAM,EAAE,EANgB;AAMZ;AACZC,IAAAA,GAAG,EAAE,EAPmB;AAOf;AACTC,IAAAA,YAAY,EAAE,CARU;AAQP;AACjBC,IAAAA,aAAa,EAAE,GATS;AASJ;AACpBC,IAAAA,YAAY,EAAE,EAVU;AAUN;AAClBC,IAAAA,QAAQ,EAAE,EAXc;AAWV;AACdC,IAAAA,YAAY,EAAE,MAZU;AAYF;AACtBC,IAAAA,aAAa,EAAE,MAbS;AAaD;AACvBC,IAAAA,WAAW,EAAE,SAdW;AAcA;AACxBC,IAAAA,MAAM,EAAE,IAfgB;AAeV;AACdC,IAAAA,QAAQ,EAAE,IAhBc;AAgBR;AAChBC,IAAAA,SAAS,EAAE,IAjBa;AAiBP;AACjBC,IAAAA,QAAQ,EAAE,IAlBc;AAkBR;AAChBC,IAAAA,aAAa,EAAE,IAnBS;AAmBH;AACrBC,IAAAA,WAAW,EAAE,IApBW;AAoBL;AACnBC,IAAAA,YAAY,EAAE,IArBU;AAqBJ;AACpBC,IAAAA,aAAa,EAAE,IAtBS;AAsBH;AACrBjC,IAAAA,QAAQ,EAAE,kBAASkC,QAAT,EAAmB;AAC5B;AACAA,MAAAA,QAAQ,CAACC,aAAT;AACA;AA1BuB,GAAzB;AA4BA,CA9BD;AAgCA;;;AACA3C,QAAQ,CAACoB,SAAT,CAAmBwB,cAAnB,GAAoC,UAAS3B,KAAT,EAAgB;AACnD;AACAjB,EAAAA,QAAQ,CAACsB,MAAT,CAAgBL,KAAhB,EAAuB;AACtBJ,IAAAA,GAAG,EAAE,IADiB;AACX;AACXC,IAAAA,IAAI,EAAE,IAFgB;AAEV;AACZS,IAAAA,MAAM,EAAE,KAHc;AAGP;AACfC,IAAAA,MAAM,EAAE,IAJc;AAIR;AACdhB,IAAAA,QAAQ,EAAE,IALY;AAKN;AAChBqC,IAAAA,IAAI,EAAE;AACLC,MAAAA,GAAG,EAAE,CADA;AACG;AACRC,MAAAA,IAAI,EAAE,EAFD;AAEK;AACVC,MAAAA,IAAI,EAAE,IAHD,CAGM;;AAHN,KANgB;AAWtBtB,IAAAA,GAAG,EAAE,EAXiB;AAWb;AACTuB,IAAAA,UAAU,EAAE,CAZU;AAYP;AACfxB,IAAAA,MAAM,EAAE,EAbc;AAaV;AACZQ,IAAAA,WAAW,EAAE,SAdS;AAcE;AACxBiB,IAAAA,UAAU,EAAE,WAfU;AAeG;AACzBhB,IAAAA,MAAM,EAAE,IAhBc;AAgBR;AACdK,IAAAA,WAAW,EAAE,IAjBS;AAiBH;AACnBY,IAAAA,UAAU,EAAE,IAlBU;AAkBJ;AAClBC,IAAAA,YAAY,EAAE,IAnBQ;AAmBF;AACpBC,IAAAA,KAAK,EAAE;AACN;AACAC,MAAAA,GAAG,EAAE,IAFC;AAEK;AACX7B,MAAAA,MAAM,EAAE,IAHF;AAGQ;AACd8B,MAAAA,QAAQ,EAAE,GAJJ;AAIS;AACfC,MAAAA,QAAQ,EAAE,IALJ;AAKU;AAChBC,MAAAA,MAAM,EAAE,IANF,CAMO;;AANP,KApBe;AA4BtBC,IAAAA,KAAK,EAAE;AACN7C,MAAAA,GAAG,EAAE,IADC;AACK;AACX8C,MAAAA,IAAI,EAAE,IAFA;AAEM;AACZC,MAAAA,GAAG,EAAE,YAHC;AAGa;AACnBC,MAAAA,OAAO,EAAE,EAJH;AAIO;AACbL,MAAAA,QAAQ,EAAE,IALJ;AAKU;AAChBC,MAAAA,MAAM,EAAE,IANF,CAMO;;AANP,KA5Be;AAoCtBK,IAAAA,QAAQ,EAAE,KApCY,CAoCN;;AApCM,GAAvB;AAsCA,CAxCD;AA0CA;;;AACA9D,QAAQ,CAACsB,MAAT,GAAkB,UAASyC,UAAT,EAAqBC,aAArB,EAAoC;AACrD,MAAI,CAACD,UAAL,EAAiB,OAAOC,aAAP;;AACjB,OAAK,IAAIC,GAAT,IAAgBD,aAAhB,EAA+B;AAC9B,QAAID,UAAU,CAACE,GAAD,CAAV,IAAmB,IAAvB,EAA6B;AAC5BF,MAAAA,UAAU,CAACE,GAAD,CAAV,GAAkBD,aAAa,CAACC,GAAD,CAA/B;AACA,KAFD,MAEO,IAAI,QAAOF,UAAU,CAACE,GAAD,CAAjB,MAA2B,QAA/B,EAAyC;AAC/CjE,MAAAA,QAAQ,CAACsB,MAAT,CAAgByC,UAAU,CAACE,GAAD,CAA1B,EAAiCD,aAAa,CAACC,GAAD,CAA9C,EAD+C,CACO;AACtD;AACD;;AACD,SAAOF,UAAP;AACA,CAVD;AAYA;;;AACA/D,QAAQ,CAACoB,SAAT,CAAmBX,cAAnB,GAAoC,YAAW;AAC9C,MAAIP,EAAE,GAAG,IAAT,CAD8C,CAE9C;;AACAA,EAAAA,EAAE,CAACU,OAAH,GAAaV,EAAE,CAACD,OAAH,CAAWM,IAAX,IAAmB,EAAhC;AACAL,EAAAA,EAAE,CAACmB,gBAAH,CAAoBnB,EAAE,CAACU,OAAvB;AAEAV,EAAAA,EAAE,CAACgE,SAAH,GAAe,CAAf,CAN8C,CAM5B;AAElB;;AACA,MAAIhE,EAAE,CAACU,OAAH,CAAWC,GAAX,IAAkBX,EAAE,CAACU,OAAH,CAAWsB,MAAjC,EAAyC;AACxC;AACAvB,IAAAA,UAAU,CAAC,YAAW;AAAE;AACvBT,MAAAA,EAAE,CAACU,OAAH,CAAWsB,MAAX,CAAkBhC,EAAlB;AACA,KAFS,EAEP,CAFO,CAAV;AAGA;AACD,CAfD;AAiBA;;;AACAF,QAAQ,CAACoB,SAAT,CAAmB+C,eAAnB,GAAqC,UAASC,CAAT,EAAY;AAChD,MAAI,CAAC,KAAKxD,OAAL,CAAaC,GAAlB,EAAuB;AACvB,MAAIX,EAAE,GAAG,IAAT;AAEAA,EAAAA,EAAE,CAACmE,UAAH,GAAgBnE,EAAE,CAACoE,QAAH,CAAYF,CAAZ,CAAhB,CAJgD,CAIhB;;AAChClE,EAAAA,EAAE,CAACqE,SAAH,GAAerE,EAAE,CAACmE,UAAlB,CALgD,CAKlB;;AAC9BnE,EAAAA,EAAE,CAACsE,aAAH,GAAmBtE,EAAE,CAACuE,aAAH,KAAqBvE,EAAE,CAACU,OAAH,CAAWiB,YAAnD,CANgD,CAMiB;;AACjE3B,EAAAA,EAAE,CAACwE,UAAH,GAAgB,KAAhB,CAPgD,CAOzB;AACvB,CARD;AAUA;;;AACA1E,QAAQ,CAACoB,SAAT,CAAmBuD,cAAnB,GAAoC,UAASP,CAAT,EAAY;AAC/C,MAAI,CAAC,KAAKxD,OAAL,CAAaC,GAAlB,EAAuB;AACvB,MAAI,CAAC,KAAKwD,UAAV,EAAsB;AACtB,MAAInE,EAAE,GAAG,IAAT,CAH+C,CAK/C;;AACA,MAAI0E,CAAC,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAR;;AACA,MAAG5E,EAAE,CAAC6E,QAAH,IAAeH,CAAC,GAAG1E,EAAE,CAAC6E,QAAP,GAAkB7E,EAAE,CAAC8E,YAAvC,EAAoD;AAAE;AACrD;AACA,GAFD,MAEK;AACJ9E,IAAAA,EAAE,CAAC6E,QAAH,GAAcH,CAAd;AACA1E,IAAAA,EAAE,CAAC8E,YAAH,GAAkB,OAAK9E,EAAE,CAACU,OAAH,CAAWc,GAAlC;AACA;;AAED,MAAIuD,SAAS,GAAG/E,EAAE,CAACgF,YAAH,EAAhB,CAd+C,CAcZ;;AACnC,MAAIC,QAAQ,GAAGjF,EAAE,CAACoE,QAAH,CAAYF,CAAZ,CAAf,CAf+C,CAehB;;AAE/B,MAAIgB,KAAK,GAAGD,QAAQ,CAACE,CAAT,GAAanF,EAAE,CAACmE,UAAH,CAAcgB,CAAvC,CAjB+C,CAiBL;AAE1C;;AACA,MAAID,KAAK,GAAG,CAAR,IAAaH,SAAS,IAAI,CAA9B,EAAiC;AAEhC;AACA,QAAI/E,EAAE,CAACU,OAAH,CAAWC,GAAX,IAAkB,CAACX,EAAE,CAACwE,UAAtB,IAAoC,CAACxE,EAAE,CAACE,eAAxC,IAA2D,CAACF,EAAE,CAACU,OAAH,CAAWW,MAAvE,KAAkF,CAACrB,EAAE,CAACG,aAAJ,IAAsBH,EAAE,CAACG,aAAH,IAC1GH,EAAE,CAACe,KAAH,CAASO,MADP,CAAJ,EACqB;AAEpB;AACA,UAAI8D,CAAC,GAAGC,IAAI,CAACC,GAAL,CAAStF,EAAE,CAACqE,SAAH,CAAae,CAAb,GAAiBH,QAAQ,CAACG,CAAnC,CAAR;AACA,UAAID,CAAC,GAAGE,IAAI,CAACC,GAAL,CAAStF,EAAE,CAACqE,SAAH,CAAac,CAAb,GAAiBF,QAAQ,CAACE,CAAnC,CAAR;AACA,UAAII,CAAC,GAAGF,IAAI,CAACG,IAAL,CAAUJ,CAAC,GAAGA,CAAJ,GAAQD,CAAC,GAAGA,CAAtB,CAAR;;AACA,UAAII,CAAC,KAAK,CAAV,EAAa;AACZ,YAAIE,KAAK,GAAGJ,IAAI,CAACK,IAAL,CAAUP,CAAC,GAAGI,CAAd,IAAmBF,IAAI,CAACM,EAAxB,GAA6B,GAAzC,CADY,CACkC;;AAC9C,YAAIF,KAAK,GAAGzF,EAAE,CAACU,OAAH,CAAWkB,QAAvB,EAAiC,OAFrB,CAE6B;AACzC,OATmB,CAWpB;;;AACA,UAAI5B,EAAE,CAACsE,aAAH,GAAmB,CAAnB,IAAwBW,QAAQ,CAACE,CAAT,IAAcnF,EAAE,CAACsE,aAA7C,EAA4D;AAC3DtE,QAAAA,EAAE,CAACwE,UAAH,GAAgB,IAAhB,CAD2D,CACrC;;AACtBxE,QAAAA,EAAE,CAAC4F,aAAH,GAF2D,CAEvC;;AACpB;AACA;;AAED5F,MAAAA,EAAE,CAAC6F,cAAH,CAAkB3B,CAAlB,EAlBoB,CAkBE;;AAEtB,UAAI4B,IAAI,GAAGb,QAAQ,CAACE,CAAT,GAAanF,EAAE,CAACqE,SAAH,CAAac,CAArC,CApBoB,CAoBoB;AAExC;;AACA,UAAInF,EAAE,CAACgE,SAAH,GAAehE,EAAE,CAACU,OAAH,CAAWa,MAA9B,EAAsC;AACrC,YAAIvB,EAAE,CAAC+F,QAAH,KAAgB,CAApB,EAAuB;AACtB/F,UAAAA,EAAE,CAAC+F,QAAH,GAAc,CAAd,CADsB,CACL;;AACjB/F,UAAAA,EAAE,CAACU,OAAH,CAAWuB,QAAX,IAAuBjC,EAAE,CAACU,OAAH,CAAWuB,QAAX,CAAoBjC,EAApB,CAAvB,CAFsB,CAE0B;;AAChDA,UAAAA,EAAE,CAACgG,UAAH,GAAgB,IAAhB,CAHsB,CAGA;AACtB;;AACDhG,QAAAA,EAAE,CAACgE,SAAH,IAAgB8B,IAAI,GAAG9F,EAAE,CAACU,OAAH,CAAWe,YAAlC,CANqC,CAMW;AAEhD;AACA,OATD,MASO;AACN,YAAIzB,EAAE,CAAC+F,QAAH,KAAgB,CAApB,EAAuB;AACtB/F,UAAAA,EAAE,CAAC+F,QAAH,GAAc,CAAd,CADsB,CACL;;AACjB/F,UAAAA,EAAE,CAACU,OAAH,CAAWwB,SAAX,IAAwBlC,EAAE,CAACU,OAAH,CAAWwB,SAAX,CAAqBlC,EAArB,CAAxB,CAFsB,CAE4B;;AAClDA,UAAAA,EAAE,CAACgG,UAAH,GAAgB,IAAhB,CAHsB,CAGA;AACtB;;AACD,YAAIF,IAAI,GAAG,CAAX,EAAc;AAAE;AACf9F,UAAAA,EAAE,CAACgE,SAAH,IAAgBqB,IAAI,CAACY,KAAL,CAAWH,IAAI,GAAG9F,EAAE,CAACU,OAAH,CAAWgB,aAA7B,CAAhB,CADa,CACgD;AAC7D,SAFD,MAEO;AAAE;AACR1B,UAAAA,EAAE,CAACgE,SAAH,IAAgB8B,IAAhB,CADM,CACgB;AACtB;AACD;;AAED,UAAII,IAAI,GAAGlG,EAAE,CAACgE,SAAH,GAAehE,EAAE,CAACU,OAAH,CAAWa,MAArC,CA7CoB,CA6CyB;;AAC7CvB,MAAAA,EAAE,CAACU,OAAH,CAAWyB,QAAX,IAAuBnC,EAAE,CAACU,OAAH,CAAWyB,QAAX,CAAoBnC,EAApB,EAAwBkG,IAAxB,EAA8BlG,EAAE,CAACgE,SAAjC,CAAvB,CA9CoB,CA8CgD;AACpE;AAED;;AACDhE,EAAAA,EAAE,CAACqE,SAAH,GAAeY,QAAf,CA1E+C,CA0EtB;AACzB,CA3ED;AA6EA;;;AACAnF,QAAQ,CAACoB,SAAT,CAAmB0E,aAAnB,GAAmC,UAAS1B,CAAT,EAAY;AAC9C,MAAI,CAAC,KAAKxD,OAAL,CAAaC,GAAlB,EAAuB,OADuB,CAE9C;;AACA,MAAI,KAAKqF,UAAT,EAAqB;AACpB,QAAIhG,EAAE,GAAG,IAAT;;AACA,QAAIA,EAAE,CAACgE,SAAH,IAAgBhE,EAAE,CAACU,OAAH,CAAWa,MAA/B,EAAuC;AACtC;AACAvB,MAAAA,EAAE,CAACc,iBAAH;AACA,KAHD,MAGO;AACN;AACAd,MAAAA,EAAE,CAACgE,SAAH,GAAe,CAAf;AACAhE,MAAAA,EAAE,CAACU,OAAH,CAAW6B,aAAX,IAA4BvC,EAAE,CAACU,OAAH,CAAW6B,aAAX,CAAyBvC,EAAzB,CAA5B;AACA;;AACDA,IAAAA,EAAE,CAAC+F,QAAH,GAAc,CAAd;AACA/F,IAAAA,EAAE,CAACgG,UAAH,GAAgB,KAAhB;AACA;AACD,CAhBD;AAkBA;;;AACAlG,QAAQ,CAACoB,SAAT,CAAmBkD,QAAnB,GAA8B,UAASF,CAAT,EAAY;AACzC,SAAO;AACNkB,IAAAA,CAAC,EAAElB,CAAC,CAACiC,OAAF,GAAYjC,CAAC,CAACiC,OAAF,CAAU,CAAV,EAAaC,KAAzB,GAAiClC,CAAC,CAACmC,OADhC;AAENlB,IAAAA,CAAC,EAAEjB,CAAC,CAACiC,OAAF,GAAYjC,CAAC,CAACiC,OAAF,CAAU,CAAV,EAAaG,KAAzB,GAAiCpC,CAAC,CAACqC;AAFhC,GAAP;AAIA,CALD;AAOA;;;AACAzG,QAAQ,CAACoB,SAAT,CAAmBJ,iBAAnB,GAAuC,YAAW;AACjD,MAAI,KAAKJ,OAAL,CAAa0B,aAAb,IAA8B,KAAK1B,OAAL,CAAa0B,aAAb,CAA2B,IAA3B,CAAlC,EAAoE,CACnE;AACA,GAFD,MAEO;AACN,SAAKoE,cAAL,GADM,CACiB;;AACvB,SAAK9F,OAAL,CAAaJ,QAAb,IAAyB,KAAKI,OAAL,CAAaJ,QAAb,CAAsB,IAAtB,CAAzB,CAFM,CAEgD;AACtD;AACD,CAPD;AASA;;;AACAR,QAAQ,CAACoB,SAAT,CAAmBsF,cAAnB,GAAoC,YAAW;AAC9C,OAAKtG,eAAL,GAAuB,IAAvB,CAD8C,CACjB;;AAC7B,OAAK8D,SAAL,GAAiB,KAAKtD,OAAL,CAAaa,MAA9B,CAF8C,CAER;;AACtC,OAAKb,OAAL,CAAa2B,WAAb,CAAyB,IAAzB,EAA+B,KAAK2B,SAApC,EAH8C,CAGE;AAChD,CAJD;AAMA;;;AACAlE,QAAQ,CAACoB,SAAT,CAAmBqB,aAAnB,GAAmC,YAAW;AAC7C,MAAIvC,EAAE,GAAG,IAAT,CAD6C,CAE7C;;AACA,MAAIyG,SAAS,GAAG,SAAZA,SAAY,GAAW;AAC1BzG,IAAAA,EAAE,CAACgE,SAAH,GAAe,CAAf;AACAhE,IAAAA,EAAE,CAACE,eAAH,GAAqB,KAArB;AACAF,IAAAA,EAAE,CAACU,OAAH,CAAW6B,aAAX,IAA4BvC,EAAE,CAACU,OAAH,CAAW6B,aAAX,CAAyBvC,EAAzB,CAA5B;AACA,GAJD,CAH6C,CAQ7C;;;AACA,MAAI0G,KAAK,GAAG,CAAZ;AACA,MAAI1G,EAAE,CAACU,OAAH,CAAW4B,YAAf,EAA6BoE,KAAK,GAAG1G,EAAE,CAACU,OAAH,CAAW4B,YAAX,CAAwBtC,EAAxB,CAAR,CAVgB,CAUqB;;AAClE,MAAI,OAAO0G,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,GAAG,CAAzC,EAA4C;AAC3CjG,IAAAA,UAAU,CAACgG,SAAD,EAAYC,KAAZ,CAAV;AACA,GAFD,MAEO;AACND,IAAAA,SAAS;AACT;AACD,CAhBD;AAkBA;;;AACA3G,QAAQ,CAACoB,SAAT,CAAmByF,cAAnB,GAAoC,UAAStF,MAAT,EAAiB;AACpD,MAAIA,MAAM,IAAI,IAAd,EAAoBA,MAAM,GAAG,IAAT;AACpB,OAAKX,OAAL,CAAaW,MAAb,GAAsBA,MAAtB;AACA,CAHD;AAKA;;;AACAvB,QAAQ,CAACoB,SAAT,CAAmBV,YAAnB,GAAkC,YAAW;AAC5C,MAAIR,EAAE,GAAG,IAAT,CAD4C,CAE5C;;AACAA,EAAAA,EAAE,CAACe,KAAH,GAAWf,EAAE,CAACD,OAAH,CAAW6G,EAAX,IAAiB;AAC3BjG,IAAAA,GAAG,EAAE;AADsB,GAA5B;AAGAX,EAAAA,EAAE,CAAC0C,cAAH,CAAkB1C,EAAE,CAACe,KAArB;AAEA,MAAIf,EAAE,CAACe,KAAH,CAASJ,GAAT,KAAiB,KAArB,EAA4B,OARgB,CAQR;;AACpCX,EAAAA,EAAE,CAACe,KAAH,CAAS8F,OAAT,GAAmB,IAAnB,CAT4C,CASnB;;AACzB7G,EAAAA,EAAE,CAACe,KAAH,CAASyC,KAAT,CAAeG,OAAf,GAAyB3D,EAAE,CAACe,KAAH,CAASyC,KAAT,CAAeG,OAAf,IAA0B3D,EAAE,CAACe,KAAH,CAASyC,KAAT,CAAesD,OAAlE,CAV4C,CAU+B;AAE3E;;AACA,MAAI9G,EAAE,CAACe,KAAH,CAASiB,MAAb,EAAqB;AACpBvB,IAAAA,UAAU,CAAC,YAAW;AAAE;AACvBT,MAAAA,EAAE,CAACe,KAAH,CAASiB,MAAT,CAAgBhC,EAAhB;AACA,KAFS,EAEP,CAFO,CAAV;AAGA;AACD,CAlBD;AAoBA;;;AACAF,QAAQ,CAACoB,SAAT,CAAmB6F,aAAnB,GAAmC,YAAW;AAC7CC,EAAAA,OAAO,CAACC,IAAR,CAAa,mCAAb,EAD6C,CACM;AACnD,CAFD;;AAGAnH,QAAQ,CAACoB,SAAT,CAAmBgG,aAAnB,GAAmC,YAAW;AAC7C,MAAI,CAAC,KAAK/G,aAAN,KAAwB,CAAC,KAAKD,eAAN,IAA0B,KAAKA,eAAL,IAAwB,KAAKQ,OAAL,CAAaY,MAAvF,CAAJ,EAAqG;AACpG,QAAI,CAAC,KAAKP,KAAL,CAAWM,MAAZ,IAAsB,KAAKN,KAAL,CAAW8F,OAArC,EAA8C;AAC7C,WAAK5F,eAAL;AACA;AACD;AACD,CAND;AAQA;;;AACAnB,QAAQ,CAACoB,SAAT,CAAmBiG,YAAnB,GAAkC,YAAW;AAC5CH,EAAAA,OAAO,CAACC,IAAR,CAAa,mCAAb,EAD4C,CACO;AACnD,CAFD;;AAGAnH,QAAQ,CAACoB,SAAT,CAAmBkG,MAAnB,GAA4B,UAASlD,CAAT,EAAYN,QAAZ,EAAsB;AACjD;AACA,MAAIc,CAAC,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAR;;AACA,MAAG,KAAKyC,UAAL,IAAmB3C,CAAC,GAAG,KAAK2C,UAAT,GAAsB,KAAKC,cAAjD,EAAgE;AAAE;AACjE;AACA,GAFD,MAEK;AACJ,SAAKD,UAAL,GAAkB3C,CAAlB;AACA,SAAK4C,cAAL,GAAsB,OAAK,KAAKvG,KAAL,CAAWS,GAAtC;AACA;;AAED,MAAIxB,EAAE,GAAG,IAAT;AACA,MAAI+E,SAAS,GAAGb,CAAC,CAACa,SAAlB,CAXiD,CAajD;;AACA,MAAIA,SAAS,GAAG,CAAZ,IAAiB/E,EAAE,CAACe,KAAH,CAASoC,KAAT,CAAeC,GAApC,EAAyC;AACxC,QAAI2B,SAAS,IAAI/E,EAAE,CAACe,KAAH,CAASoC,KAAT,CAAe5B,MAAhC,EAAwC;AACvCvB,MAAAA,EAAE,CAACuH,UAAH;AACA,KAFD,MAEO;AACNvH,MAAAA,EAAE,CAACwH,UAAH;AACA;AACD,GApBgD,CAsBjD;;;AACA,MAAIxH,EAAE,CAACe,KAAH,CAAS6C,QAAT,IAAqBA,QAAzB,EAAmC;AAClC;AACA,QAAI5D,EAAE,CAACyH,UAAH,IAAiB,IAArB,EAA2BzH,EAAE,CAACyH,UAAH,GAAgB,CAAhB;AAC3BzH,IAAAA,EAAE,CAAC0H,UAAH,GAAgB3C,SAAS,GAAG/E,EAAE,CAACyH,UAAf,GAA4B,CAA5C;AACAzH,IAAAA,EAAE,CAACyH,UAAH,GAAgB1C,SAAhB,CAJkC,CAKlC;;AACAnB,IAAAA,QAAQ,CAAC5D,EAAD,EAAK+E,SAAL,EAAgB/E,EAAE,CAAC0H,UAAnB,CAAR;AACA;;AAED1H,EAAAA,EAAE,CAAC2H,YAAH,CAAgB5C,SAAhB;AACA,CAjCD;AAmCA;;;AACAjF,QAAQ,CAACoB,SAAT,CAAmBD,eAAnB,GAAqC,YAAW;AAC/C,MAAI,KAAKF,KAAL,CAAWT,QAAX,IAAuB,CAAC,KAAKH,aAAjC,EAAgD;AAC/C,SAAKyH,YAAL,GAD+C,CAC1B;;AACrB,SAAK7G,KAAL,CAAW4B,IAAX,CAAgBC,GAAhB,GAF+C,CAExB;;AACvB,SAAK5B,YAAL,GAAoB,IAApB,CAH+C,CAGrB;;AAC1B,SAAK4B,GAAL,GAAW,KAAK7B,KAAL,CAAW4B,IAAX,CAAgBC,GAA3B,CAJ+C,CAIf;;AAChC,SAAKC,IAAL,GAAY,KAAK9B,KAAL,CAAW4B,IAAX,CAAgBE,IAA5B,CAL+C,CAKb;;AAClC,SAAKC,IAAL,GAAY,KAAK/B,KAAL,CAAW4B,IAAX,CAAgBG,IAA5B,CAN+C,CAMb;;AAClC,SAAK/B,KAAL,CAAWT,QAAX,CAAoB,IAApB,EAP+C,CAOpB;AAC3B;AACD,CAVD;AAYA;;;AACAR,QAAQ,CAACoB,SAAT,CAAmB0G,YAAnB,GAAkC,YAAW;AAC5C,OAAKzH,aAAL,GAAqB,IAArB,CAD4C,CACjB;;AAC3B,OAAKY,KAAL,CAAWsB,WAAX,IAA0B,KAAKtB,KAAL,CAAWsB,WAAX,CAAuB,IAAvB,CAA1B,CAF4C,CAEY;AACxD,CAHD;AAKA;;;AACAvC,QAAQ,CAACoB,SAAT,CAAmB+B,UAAnB,GAAgC,YAAW;AAC1C,OAAKlC,KAAL,CAAW8F,OAAX,GAAqB,KAArB,CAD0C,CACd;;AAC5B,OAAK9F,KAAL,CAAWkC,UAAX,IAAyB,KAAKlC,KAAL,CAAWkC,UAAX,CAAsB,IAAtB,CAAzB,CAF0C,CAEY;AACtD,CAHD;AAKA;;;AACAnD,QAAQ,CAACoB,SAAT,CAAmBgC,YAAnB,GAAkC,YAAW;AAC5C,OAAKnC,KAAL,CAAWmC,YAAX,IAA2B,KAAKnC,KAAL,CAAWmC,YAAX,CAAwB,IAAxB,CAA3B,CAD4C,CACc;AAC1D,CAFD;AAIA;;;AACApD,QAAQ,CAACoB,SAAT,CAAmB2G,WAAnB,GAAiC,UAASC,YAAT,EAAuB;AACvD,MAAIA,YAAY,IAAI,IAApB,EAA0B;AAAE;AAC3B,QAAIA,YAAJ,EAAkB;AACjB,WAAK7E,UAAL,GADiB,CACE;AACnB,KAFD,MAEO;AACN,WAAKC,YAAL,GADM,CACe;AACrB;AACD;;AACD,OAAK/C,aAAL,GAAqB,KAArB,CARuD,CAQ3B;AAC5B,CATD;AAWA;;;;;;;;AAMAL,QAAQ,CAACoB,SAAT,CAAmBuB,aAAnB,GAAmC,UAASsF,aAAT,EAAwB;AAC1D,MAAI,KAAKhH,KAAL,IAAc,KAAKA,KAAL,CAAWJ,GAA7B,EAAkC;AACjC,QAAIgC,IAAI,GAAG,KAAK5B,KAAL,CAAW4B,IAAtB;AACA,SAAKqF,UAAL,GAAkBrF,IAAI,CAACC,GAAvB,CAFiC,CAEL;;AAC5B,SAAKqF,WAAL,GAAmBtF,IAAI,CAACG,IAAxB,CAHiC,CAGH;;AAC9BH,IAAAA,IAAI,CAACC,GAAL,GAAW,CAAX,CAJiC,CAInB;;AACdD,IAAAA,IAAI,CAACG,IAAL,GAAY,IAAZ,CALiC,CAKf;;AAClB,QAAI,CAAC,KAAK5C,eAAN,IAAyB6H,aAAa,KAAK,KAA/C,EAAsD;AAAE;AACvD,UAAIA,aAAa,IAAI,IAArB,EAA2B;AAC1B,aAAKG,WAAL,GAD0B,CACN;;AACpB,aAAKN,YAAL,GAF0B,CAEL;AACrB,OAHD,MAGO;AACN,aAAKpB,cAAL,GADM,CACiB;AACvB;AACD;;AACD,SAAKxF,YAAL,GAAoB,IAApB,CAdiC,CAcP;;AAC1B,SAAK4B,GAAL,GAAWD,IAAI,CAACC,GAAhB,CAfiC,CAeZ;;AACrB,SAAKC,IAAL,GAAYF,IAAI,CAACE,IAAjB,CAhBiC,CAgBV;;AACvB,SAAKC,IAAL,GAAYH,IAAI,CAACG,IAAjB,CAjBiC,CAiBV;;AACvB,SAAK/B,KAAL,CAAWT,QAAX,IAAuB,KAAKS,KAAL,CAAWT,QAAX,CAAoB,IAApB,CAAvB,CAlBiC,CAkBiB;AAClD;AACD,CArBD;AAuBA;;;AACAR,QAAQ,CAACoB,SAAT,CAAmBiH,UAAnB,GAAgC,UAASvF,GAAT,EAAc;AAC7C,OAAK7B,KAAL,CAAW4B,IAAX,CAAgBC,GAAhB,GAAsBA,GAAG,GAAG,CAA5B;AACA,CAFD;AAIA;;;AACA9C,QAAQ,CAACoB,SAAT,CAAmBkH,WAAnB,GAAiC,UAASvF,IAAT,EAAe;AAC/C,OAAK9B,KAAL,CAAW4B,IAAX,CAAgBE,IAAhB,GAAuBA,IAAvB;AACA,CAFD;AAIA;;;;;;;AAKA/C,QAAQ,CAACoB,SAAT,CAAmBmH,SAAnB,GAA+B,UAASC,QAAT,EAAmBC,SAAnB,EAA8BC,OAA9B,EAAuC;AACrE,MAAI3B,OAAJ;AACA,MAAI,KAAK9F,KAAL,CAAWJ,GAAX,IAAkB4H,SAAS,IAAI,IAAnC,EAAyC1B,OAAO,GAAG,KAAK9F,KAAL,CAAW4B,IAAX,CAAgBC,GAAhB,GAAsB2F,SAAhC,CAF4B,CAEe;;AACpF,OAAKE,UAAL,CAAgBH,QAAhB,EAA0BzB,OAA1B,EAAmC2B,OAAnC;AACA,CAJD;AAMA;;;;;;;AAKA1I,QAAQ,CAACoB,SAAT,CAAmBwH,SAAnB,GAA+B,UAASJ,QAAT,EAAmBK,SAAnB,EAA8BH,OAA9B,EAAuC;AACrE,MAAI3B,OAAJ;;AACA,MAAI,KAAK9F,KAAL,CAAWJ,GAAX,IAAkBgI,SAAS,IAAI,IAAnC,EAAyC;AACxC,QAAIC,QAAQ,GAAG,CAAC,KAAK7H,KAAL,CAAW4B,IAAX,CAAgBC,GAAhB,GAAsB,CAAvB,IAA4B,KAAK7B,KAAL,CAAW4B,IAAX,CAAgBE,IAA5C,GAAmDyF,QAAlE,CADwC,CACoC;;AAC5EzB,IAAAA,OAAO,GAAG+B,QAAQ,GAAGD,SAArB,CAFwC,CAER;AAChC;;AACD,OAAKF,UAAL,CAAgBH,QAAhB,EAA0BzB,OAA1B,EAAmC2B,OAAnC;AACA,CAPD;AASA;;;;;;;AAKA1I,QAAQ,CAACoB,SAAT,CAAmBuH,UAAnB,GAAgC,UAASH,QAAT,EAAmBzB,OAAnB,EAA4B2B,OAA5B,EAAqC;AACpE,MAAIxI,EAAE,GAAG,IAAT,CADoE,CAEpE;;AACA,MAAIA,EAAE,CAACE,eAAP,EAAwBF,EAAE,CAACuC,aAAH,GAH4C,CAKpE;;AACA,MAAIvC,EAAE,CAACe,KAAH,CAASJ,GAAb,EAAkB;AACjB,QAAImH,YAAJ,CADiB,CACC;;AAClB,QAAIQ,QAAQ,IAAI,IAAhB,EAAsB;AACrB,UAAIO,OAAO,GAAG7I,EAAE,CAACe,KAAH,CAAS4B,IAAT,CAAcC,GAA5B,CADqB,CACY;;AACjC,UAAIkG,QAAQ,GAAG9I,EAAE,CAACe,KAAH,CAAS4B,IAAT,CAAcE,IAA7B,CAFqB,CAEc;AACnC;;AACA,UAAIgG,OAAO,KAAK,CAAhB,EAAmB;AAClB,YAAIL,OAAJ,EAAaxI,EAAE,CAACe,KAAH,CAAS4B,IAAT,CAAcG,IAAd,GAAqB0F,OAArB,CADK,CACyB;AAC3C;;AACD,UAAIF,QAAQ,GAAGQ,QAAX,IAAuBjC,OAAO,KAAK,KAAvC,EAA8C;AAC7C;AACA7G,QAAAA,EAAE,CAACe,KAAH,CAAS8F,OAAT,GAAmB,KAAnB;;AACA,YAAIyB,QAAQ,KAAK,CAAb,IAAkBO,OAAO,KAAK,CAAlC,EAAqC;AACpC;AACAf,UAAAA,YAAY,GAAG,KAAf;AACA9H,UAAAA,EAAE,CAAC+I,SAAH;AACA,SAJD,MAIO;AACN;AACA,cAAIC,WAAW,GAAG,CAACH,OAAO,GAAG,CAAX,IAAgBC,QAAhB,GAA2BR,QAA7C;;AACA,cAAIU,WAAW,GAAGhJ,EAAE,CAACe,KAAH,CAASgC,UAA3B,EAAuC;AACtC+E,YAAAA,YAAY,GAAG,KAAf;AACA,WAFD,MAEO;AACNA,YAAAA,YAAY,GAAG,IAAf;AACA;;AACD9H,UAAAA,EAAE,CAACkI,WAAH,GARM,CAQY;AAClB;AACD,OAjBD,MAiBO;AACN;AACAJ,QAAAA,YAAY,GAAG,KAAf;AACA9H,QAAAA,EAAE,CAACe,KAAH,CAAS8F,OAAT,GAAmB,IAAnB;AACA7G,QAAAA,EAAE,CAACkI,WAAH,GAJM,CAIY;AAClB;AACD,KAhCgB,CAkCjB;;;AACAlI,IAAAA,EAAE,CAAC6H,WAAH,CAAeC,YAAf;AACA;AACD,CA3CD;AA6CA;;;AACAhI,QAAQ,CAACoB,SAAT,CAAmB+H,MAAnB,GAA4B,YAAW;AACtC;AACA,MAAI,KAAK/I,eAAT,EAA0B;AACzB,QAAIyC,IAAI,GAAG,KAAK5B,KAAL,CAAW4B,IAAtB;;AACA,QAAIA,IAAI,IAAI,KAAKqF,UAAjB,EAA6B;AAC5BrF,MAAAA,IAAI,CAACC,GAAL,GAAW,KAAKoF,UAAhB;AACArF,MAAAA,IAAI,CAACG,IAAL,GAAY,KAAKmF,WAAjB;AACA;;AACD,SAAK1F,aAAL;AACA,GATqC,CAUtC;;;AACA,MAAI,KAAKpC,aAAT,EAAwB;AACvB,SAAKY,KAAL,CAAW4B,IAAX,CAAgBC,GAAhB;AACA,SAAKiF,WAAL,CAAiB,KAAjB;AACA,SAAKqB,QAAL,CAAc,KAAKlE,YAAL,KAAsB,CAApC,EAAuC,CAAvC,EAHuB,CAGmB;AAC1C;AACD,CAhBD;AAkBA;;;AACAlF,QAAQ,CAACoB,SAAT,CAAmB6H,SAAnB,GAA+B,YAAW;AACzC,OAAKhI,KAAL,CAAWyC,KAAX,CAAiB7C,GAAjB,IAAwB,KAAKI,KAAL,CAAWyC,KAAX,CAAiBD,MAAzC,IAAmD,KAAKxC,KAAL,CAAWyC,KAAX,CAAiBD,MAAjB,CAAwB,IAAxB,CAAnD;AACA,CAFD;AAIA;;;AACAzD,QAAQ,CAACoB,SAAT,CAAmBgH,WAAnB,GAAiC,YAAW;AAC3C,OAAKnH,KAAL,CAAWyC,KAAX,CAAiBD,MAAjB,IAA2B,KAAKxC,KAAL,CAAWyC,KAAX,CAAiBD,MAAjB,CAAwB,KAAxB,CAA3B;AACA,CAFD;AAIA;;;AACAzD,QAAQ,CAACoB,SAAT,CAAmBqG,UAAnB,GAAgC,YAAW;AAC1C,MAAI,KAAKxG,KAAL,CAAWoC,KAAX,CAAiBC,GAAjB,IAAwB,CAAC,KAAK+F,UAAlC,EAA8C;AAC7C,SAAKA,UAAL,GAAkB,IAAlB;AACA,SAAKpI,KAAL,CAAWoC,KAAX,CAAiBI,MAAjB,IAA2B,KAAKxC,KAAL,CAAWoC,KAAX,CAAiBI,MAAjB,CAAwB,IAAxB,CAA3B;AACA;AACD,CALD;AAOA;;;AACAzD,QAAQ,CAACoB,SAAT,CAAmBsG,UAAnB,GAAgC,YAAW;AAC1C,MAAI,KAAKzG,KAAL,CAAWoC,KAAX,CAAiBC,GAAjB,IAAwB,KAAK+F,UAAjC,EAA6C;AAC5C,SAAKA,UAAL,GAAkB,KAAlB;AACA,SAAKpI,KAAL,CAAWoC,KAAX,CAAiBI,MAAjB,IAA2B,KAAKxC,KAAL,CAAWoC,KAAX,CAAiBI,MAAjB,CAAwB,KAAxB,CAA3B;AACA;AACD,CALD;AAOA;;;AACAzD,QAAQ,CAACoB,SAAT,CAAmB8D,YAAnB,GAAkC,YAAW;AAC5C,SAAO,KAAKD,SAAL,IAAkB,CAAzB;AACA,CAFD;AAIA;;;AACAjF,QAAQ,CAACoB,SAAT,CAAmByG,YAAnB,GAAkC,UAASxC,CAAT,EAAY;AAC7C,OAAKJ,SAAL,GAAiBI,CAAjB;AACA,CAFD;AAIA;;;AACArF,QAAQ,CAACoB,SAAT,CAAmBgI,QAAnB,GAA8B,UAAS/D,CAAT,EAAYT,CAAZ,EAAe;AAC5C,OAAK0E,UAAL,IAAiB,KAAKA,UAAL,CAAgBjE,CAAhB,EAAmBT,CAAnB,CAAjB,CAD4C,CACL;AACvC,CAFD;AAIA;;;AACA5E,QAAQ,CAACoB,SAAT,CAAmBmI,aAAnB,GAAmC,UAASD,UAAT,EAAqB;AACvD,OAAKA,UAAL,GAAkBA,UAAlB;AACA,CAFD;AAIA;;;;;;;;;AAOAtJ,QAAQ,CAACoB,SAAT,CAAmBoI,OAAnB,GAA6B,UAASC,IAAT,EAAeC,GAAf,EAAoBlJ,QAApB,EAA8BoE,CAA9B,EAAiCwB,IAAjC,EAAuC;AACnE,MAAIJ,IAAI,GAAG0D,GAAG,GAAGD,IAAjB,CADmE,CAC5C;;AACvB,MAAI7E,CAAC,KAAK,CAAN,IAAWoB,IAAI,KAAK,CAAxB,EAA2B;AAC1BxF,IAAAA,QAAQ,IAAIA,QAAQ,CAACkJ,GAAD,CAApB;AACA;AACA;;AACD9E,EAAAA,CAAC,GAAGA,CAAC,IAAI,GAAT,CANmE,CAMrD;;AACdwB,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf,CAPmE,CAOhD;;AACnB,MAAIuD,KAAK,GAAG/E,CAAC,GAAGwB,IAAhB,CARmE,CAQ7C;;AACtB,MAAIwD,IAAI,GAAG5D,IAAI,GAAG2D,KAAlB,CATmE,CAS1C;;AACzB,MAAIE,CAAC,GAAG,CAAR,CAVmE,CAUxD;;AACX,MAAIC,KAAK,GAAGC,WAAW,CAAC,YAAW;AAClC,QAAIF,CAAC,GAAGF,KAAK,GAAG,CAAhB,EAAmB;AAClBF,MAAAA,IAAI,IAAIG,IAAR;AACApJ,MAAAA,QAAQ,IAAIA,QAAQ,CAACiJ,IAAD,EAAOK,KAAP,CAApB;AACAD,MAAAA,CAAC;AACD,KAJD,MAIO;AACNrJ,MAAAA,QAAQ,IAAIA,QAAQ,CAACkJ,GAAD,EAAMI,KAAN,CAApB,CADM,CAC4B;;AAClCE,MAAAA,aAAa,CAACF,KAAD,CAAb;AACA;AACD,GATsB,EASpB1D,IAToB,CAAvB;AAUA,CArBD;AAuBA;;;AACApG,QAAQ,CAACoB,SAAT,CAAmBqD,aAAnB,GAAmC,YAAW;AAC7C,SAAO,KAAKwF,UAAL,IAAmB,CAA1B;AACA,CAFD;;AAIAjK,QAAQ,CAACoB,SAAT,CAAmB8I,aAAnB,GAAmC,UAASC,CAAT,EAAY;AAC9C,OAAKF,UAAL,GAAkBE,CAAlB;AACA,CAFD;AAIA;;;AACAnK,QAAQ,CAACoB,SAAT,CAAmB2E,cAAnB,GAAoC,UAAS3B,CAAT,EAAY;AAC/C;AACA;AACA;AACAA,EAAAA,CAAC,IAAIA,CAAC,CAAC2B,cAAF,EAAL;AACA,CALD","sourcesContent":["/* mescroll\n * version 1.1.0\n * 2019-07-01 lichubiao\n */\n\nexport default function MeScroll(options) {\n\tlet me = this;\n\tme.version = '1.1.0'; // mescroll版本号\n\tme.options = options || {}; // 配置\n\n\tme.isDownScrolling = false; // 是否在执行下拉刷新的回调\n\tme.isUpScrolling = false; // 是否在执行上拉加载的回调\n\tlet hasDownCallback = me.options.down && me.options.down.callback; // 是否配置了down的callback\n\n\t// 初始化下拉刷新\n\tme.initDownScroll();\n\t// 初始化上拉加载,则初始化\n\tme.initUpScroll();\n\n\t// 自动加载\n\tsetTimeout(function() { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n\t\t// 自动触发下拉刷新 (只有配置了down的callback才自动触发下拉刷新)\n\t\tif (me.optDown.use && me.optDown.auto && hasDownCallback) {\n\t\t\tif (me.optDown.autoShowLoading) {\n\t\t\t\tme.triggerDownScroll(); // 显示下拉进度,执行下拉回调\n\t\t\t} else {\n\t\t\t\tme.optDown.callback && me.optDown.callback(me); // 不显示下拉进度,直接执行下拉回调\n\t\t\t}\n\t\t}\n\t\t// 自动触发上拉加载\n\t\tme.optUp.use && me.optUp.auto && !me.isUpAutoLoad && me.triggerUpScroll();\n\t}, 30); // 需让me.optDown.inited和me.optUp.inited先执行\n}\n\n/* 配置参数:下拉刷新 */\nMeScroll.prototype.extendDownScroll = function(optDown) {\n\t// 下拉刷新的配置\n\tMeScroll.extend(optDown, {\n\t\tuse: true, // 是否启用下拉刷新; 默认true\n\t\tauto: true, // 是否在初始化完毕之后自动执行下拉刷新的回调; 默认true\n\t\tautoShowLoading: false, // 如果设置auto=true(在初始化完毕之后自动执行下拉刷新的回调),那么是否显示下拉刷新的进度; 默认false\n\t\tisLock: false, // 是否锁定下拉刷新,默认false;\n\t\tisBoth: true, // 下拉刷新时,如果滑动到列表底部是否可以同时触发上拉加载;默认true,两者可同时触发;\n\t\toffset: 80, // 在列表顶部,下拉大于80px,松手即可触发下拉刷新的回调\n\t\tfps: 40, // 下拉节流 (值越大每秒刷新频率越高)\n\t\tinOffsetRate: 1, // 在列表顶部,下拉的距离小于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\n\t\toutOffsetRate: 0.2, // 在列表顶部,下拉的距离大于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\n\t\tbottomOffset: 20, // 当手指touchmove位置在距离body底部20px范围内的时候结束上拉刷新,避免Webview嵌套导致touchend事件不执行\n\t\tminAngle: 45, // 向下滑动最少偏移的角度,取值区间  [0,90];默认45度,即向下滑动的角度大于45度则触发下拉;而小于45度,将不触发下拉,避免与左右滑动的轮播等组件冲突;\n\t\ttextInOffset: '下拉刷新', // 下拉的距离在offset范围内的提示文本\n\t\ttextOutOffset: '释放更新', // 下拉的距离大于offset范围的提示文本\n\t\ttextLoading: '加载中 ...', // 加载中的提示文本\n\t\tinited: null, // 下拉刷新初始化完毕的回调\n\t\tinOffset: null, // 下拉的距离进入offset范围内那一刻的回调\n\t\toutOffset: null, // 下拉的距离大于offset那一刻的回调\n\t\tonMoving: null, // 下拉过程中的回调,滑动过程一直在执行; rate下拉区域当前高度与指定距离的比值(inOffset: rate<1; outOffset: rate>=1); downHight当前下拉区域的高度\n\t\tbeforeLoading: null, // 准备触发下拉刷新的回调: 如果return true,将不触发showLoading和callback回调; 常用来完全自定义下拉刷新, 参考案例【淘宝 v6.8.0】\n\t\tshowLoading: null, // 显示下拉刷新进度的回调\n\t\tafterLoading: null, // 准备结束下拉的回调. 返回结束下拉的延时执行时间,默认0ms; 常用于结束下拉之前再显示另外一小段动画,才去隐藏下拉刷新的场景, 参考案例【dotJump】\n\t\tendDownScroll: null, // 结束下拉刷新的回调\n\t\tcallback: function(mescroll) {\n\t\t\t// 下拉刷新的回调;默认重置上拉加载列表为第一页\n\t\t\tmescroll.resetUpScroll();\n\t\t}\n\t})\n}\n\n/* 配置参数:上拉加载 */\nMeScroll.prototype.extendUpScroll = function(optUp) {\n\t// 上拉加载的配置\n\tMeScroll.extend(optUp, {\n\t\tuse: true, // 是否启用上拉加载; 默认true\n\t\tauto: true, // 是否在初始化完毕之后自动执行上拉加载的回调; 默认true\n\t\tisLock: false, // 是否锁定上拉加载,默认false;\n\t\tisBoth: true, // 上拉加载时,如果滑动到列表顶部是否可以同时触发下拉刷新;默认true,两者可同时触发;\n\t\tcallback: null, // 上拉加载的回调;function(page,mescroll){ }\n\t\tpage: {\n\t\t\tnum: 0, // 当前页码,默认0,回调之前会加1,即callback(page)会从1开始\n\t\t\tsize: 10, // 每页数据的数量\n\t\t\ttime: null // 加载第一页数据服务器返回的时间; 防止用户翻页时,后台新增了数据从而导致下一页数据重复;\n\t\t},\n\t\tfps: 40, // 上拉节流 (值越大每秒刷新频率越高)\n\t\tnoMoreSize: 5, // 如果列表已无数据,可设置列表的总数量要大于等于5条才显示无更多数据;避免列表数据过少(比如只有一条数据),显示无更多数据会不好看\n\t\toffset: 80, // 距底部多远时,触发upCallback\n\t\ttextLoading: '加载中 ...', // 加载中的提示文本\n\t\ttextNoMore: '-- END --', // 没有更多数据的提示文本\n\t\tinited: null, // 初始化完毕的回调\n\t\tshowLoading: null, // 显示加载中的回调\n\t\tshowNoMore: null, // 显示无更多数据的回调\n\t\thideUpScroll: null, // 隐藏上拉加载的回调\n\t\ttoTop: {\n\t\t\t// 回到顶部按钮,需配置src才显示\n\t\t\tsrc: null, // 图片路径,默认null (建议写成网络图,不必考虑相对路径)\n\t\t\toffset: 1000, // 列表滚动多少距离才显示回到顶部按钮,默认1000\n\t\t\tduration: 300, // 回到顶部的动画时长,默认300ms\n\t\t\tbtnClick: null, // 点击按钮的回调\n\t\t\tonShow: null // 是否显示的回调\n\t\t},\n\t\tempty: {\n\t\t\tuse: true, // 是否显示空布局\n\t\t\ticon: null, // 图标路径\n\t\t\ttip: '~ 暂无相关数据 ~', // 提示\n\t\t\tbtnText: '', // 按钮\n\t\t\tbtnClick: null, // 点击按钮的回调\n\t\t\tonShow: null // 是否显示的回调\n\t\t},\n\t\tonScroll: false // 是否监听滚动事件\n\t})\n}\n\n/* 配置参数 */\nMeScroll.extend = function(userOption, defaultOption) {\n\tif (!userOption) return defaultOption;\n\tfor (let key in defaultOption) {\n\t\tif (userOption[key] == null) {\n\t\t\tuserOption[key] = defaultOption[key];\n\t\t} else if (typeof userOption[key] === 'object') {\n\t\t\tMeScroll.extend(userOption[key], defaultOption[key]); // 深度匹配\n\t\t}\n\t}\n\treturn userOption;\n}\n\n/* -------初始化下拉刷新------- */\nMeScroll.prototype.initDownScroll = function() {\n\tlet me = this;\n\t// 配置参数\n\tme.optDown = me.options.down || {};\n\tme.extendDownScroll(me.optDown);\n\n\tme.downHight = 0; // 下拉区域的高度\n\n\t// 在页面中加入下拉布局\n\tif (me.optDown.use && me.optDown.inited) {\n\t\t// 初始化完毕的回调\n\t\tsetTimeout(function() { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n\t\t\tme.optDown.inited(me);\n\t\t}, 0)\n\t}\n}\n\n/* 列表touchstart事件 */\nMeScroll.prototype.touchstartEvent = function(e) {\n\tif (!this.optDown.use) return;\n\tlet me = this;\n\n\tme.startPoint = me.getPoint(e); // 记录起点\n\tme.lastPoint = me.startPoint; // 重置上次move的点\n\tme.maxTouchmoveY = me.getBodyHeight() - me.optDown.bottomOffset; // 手指触摸的最大范围(写在touchstart避免body获取高度为0的情况)\n\tme.inTouchend = false; // 标记不是touchend\n}\n\n/* 列表touchmove事件 */\nMeScroll.prototype.touchmoveEvent = function(e) {\n\tif (!this.optDown.use) return;\n\tif (!this.startPoint) return;\n\tlet me = this;\n\t\n\t// 节流\n\tlet t = new Date().getTime();\n\tif(me.moveTime && t - me.moveTime < me.moveTimeDiff){ // 小于节流时间,则不处理\n\t\treturn;\n\t}else{\n\t\tme.moveTime = t\n\t\tme.moveTimeDiff = 1000/me.optDown.fps\n\t}\n\t\n\tlet scrollTop = me.getScrollTop(); // 当前滚动条的距离\n\tlet curPoint = me.getPoint(e); // 当前点\n\n\tlet moveY = curPoint.y - me.startPoint.y; // 和起点比,移动的距离,大于0向下拉,小于0向上拉\n\n\t// (向下拉&&在顶部)\n\tif (moveY > 0 && scrollTop <= 0) {\n\n\t\t// 可下拉的条件\n\t\tif (me.optDown.use && !me.inTouchend && !me.isDownScrolling && !me.optDown.isLock && (!me.isUpScrolling || (me.isUpScrolling &&\n\t\t\t\tme.optUp.isBoth))) {\n\n\t\t\t// 下拉的角度是否在配置的范围内\n\t\t\tlet x = Math.abs(me.lastPoint.x - curPoint.x);\n\t\t\tlet y = Math.abs(me.lastPoint.y - curPoint.y);\n\t\t\tlet z = Math.sqrt(x * x + y * y);\n\t\t\tif (z !== 0) {\n\t\t\t\tlet angle = Math.asin(y / z) / Math.PI * 180; // 两点之间的角度,区间 [0,90]\n\t\t\t\tif (angle < me.optDown.minAngle) return; // 如果小于配置的角度,则不往下执行下拉刷新\n\t\t\t}\n\n\t\t\t// 如果手指的位置超过配置的距离,则提前结束下拉,避免Webview嵌套导致touchend无法触发\n\t\t\tif (me.maxTouchmoveY > 0 && curPoint.y >= me.maxTouchmoveY) {\n\t\t\t\tme.inTouchend = true; // 标记执行touchend\n\t\t\t\tme.touchendEvent(); // 提前触发touchend\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tme.preventDefault(e); // 阻止默认事件\n\n\t\t\tlet diff = curPoint.y - me.lastPoint.y; // 和上次比,移动的距离 (大于0向下,小于0向上)\n\n\t\t\t// 下拉距离  < 指定距离\n\t\t\tif (me.downHight < me.optDown.offset) {\n\t\t\t\tif (me.movetype !== 1) {\n\t\t\t\t\tme.movetype = 1; // 加入标记,保证只执行一次\n\t\t\t\t\tme.optDown.inOffset && me.optDown.inOffset(me); // 进入指定距离范围内那一刻的回调,只执行一次\n\t\t\t\t\tme.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\n\t\t\t\t}\n\t\t\t\tme.downHight += diff * me.optDown.inOffsetRate; // 越往下,高度变化越小\n\n\t\t\t\t// 指定距离  <= 下拉距离\n\t\t\t} else {\n\t\t\t\tif (me.movetype !== 2) {\n\t\t\t\t\tme.movetype = 2; // 加入标记,保证只执行一次\n\t\t\t\t\tme.optDown.outOffset && me.optDown.outOffset(me); // 下拉超过指定距离那一刻的回调,只执行一次\n\t\t\t\t\tme.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\n\t\t\t\t}\n\t\t\t\tif (diff > 0) { // 向下拉\n\t\t\t\t\tme.downHight += Math.round(diff * me.optDown.outOffsetRate); // 越往下,高度变化越小\n\t\t\t\t} else { // 向上收\n\t\t\t\t\tme.downHight += diff; // 向上收回高度,则向上滑多少收多少高度\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet rate = me.downHight / me.optDown.offset; // 下拉区域当前高度与指定距离的比值\n\t\t\tme.optDown.onMoving && me.optDown.onMoving(me, rate, me.downHight); // 下拉过程中的回调,一直在执行\n\t\t}\n\n\t}\n\tme.lastPoint = curPoint; // 记录本次移动的点\n}\n\n/* 列表touchend事件 */\nMeScroll.prototype.touchendEvent = function(e) {\n\tif (!this.optDown.use) return;\n\t// 如果下拉区域高度已改变,则需重置回来\n\tif (this.isMoveDown) {\n\t\tlet me = this;\n\t\tif (me.downHight >= me.optDown.offset) {\n\t\t\t// 符合触发刷新的条件\n\t\t\tme.triggerDownScroll();\n\t\t} else {\n\t\t\t// 不符合的话 则重置\n\t\t\tme.downHight = 0;\n\t\t\tme.optDown.endDownScroll && me.optDown.endDownScroll(me);\n\t\t}\n\t\tme.movetype = 0;\n\t\tme.isMoveDown = false;\n\t}\n}\n\n/* 根据点击滑动事件获取第一个手指的坐标 */\nMeScroll.prototype.getPoint = function(e) {\n\treturn {\n\t\tx: e.touches ? e.touches[0].pageX : e.clientX,\n\t\ty: e.touches ? e.touches[0].pageY : e.clientY\n\t}\n}\n\n/* 触发下拉刷新 */\nMeScroll.prototype.triggerDownScroll = function() {\n\tif (this.optDown.beforeLoading && this.optDown.beforeLoading(this)) {\n\t\t//return true则处于完全自定义状态\n\t} else {\n\t\tthis.showDownScroll(); // 下拉刷新中...\n\t\tthis.optDown.callback && this.optDown.callback(this); // 执行回调,联网加载数据\n\t}\n}\n\n/* 显示下拉进度布局 */\nMeScroll.prototype.showDownScroll = function() {\n\tthis.isDownScrolling = true; // 标记下拉中\n\tthis.downHight = this.optDown.offset; // 更新下拉区域高度\n\tthis.optDown.showLoading(this, this.downHight); // 下拉刷新中...\n}\n\n/* 结束下拉刷新 */\nMeScroll.prototype.endDownScroll = function() {\n\tlet me = this;\n\t// 结束下拉刷新的方法\n\tlet endScroll = function() {\n\t\tme.downHight = 0;\n\t\tme.isDownScrolling = false;\n\t\tme.optDown.endDownScroll && me.optDown.endDownScroll(me);\n\t}\n\t// 结束下拉刷新时的回调\n\tlet delay = 0;\n\tif (me.optDown.afterLoading) delay = me.optDown.afterLoading(me); // 结束下拉刷新的延时,单位ms\n\tif (typeof delay === 'number' && delay > 0) {\n\t\tsetTimeout(endScroll, delay);\n\t} else {\n\t\tendScroll();\n\t}\n}\n\n/* 锁定下拉刷新:isLock=ture,null锁定;isLock=false解锁 */\nMeScroll.prototype.lockDownScroll = function(isLock) {\n\tif (isLock == null) isLock = true;\n\tthis.optDown.isLock = isLock;\n}\n\n/* -------初始化上拉加载------- */\nMeScroll.prototype.initUpScroll = function() {\n\tlet me = this;\n\t// 配置参数\n\tme.optUp = me.options.up || {\n\t\tuse: false\n\t};\n\tme.extendUpScroll(me.optUp);\n\n\tif (me.optUp.use === false) return; // 配置不使用上拉加载时,则不初始化上拉布局\n\tme.optUp.hasNext = true; // 如果使用上拉,则默认有下一页\n\tme.optUp.empty.btnText = me.optUp.empty.btnText || me.optUp.empty.btntext; // 兼容以前版本的btntext\n\n\t// 初始化完毕的回调\n\tif (me.optUp.inited) {\n\t\tsetTimeout(function() { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n\t\t\tme.optUp.inited(me);\n\t\t}, 0)\n\t}\n}\n\n/*滚动到底部的事件*/\nMeScroll.prototype.onReachBottom = function() {\n\tconsole.warn('当前版本无需再调用mescroll.onReachBottom()'); // 兼容1.0.3以下版本,防止报错\n}\nMeScroll.prototype.scrolltolower = function() {\n\tif (!this.isUpScrolling && (!this.isDownScrolling || (this.isDownScrolling && this.optDown.isBoth))) {\n\t\tif (!this.optUp.isLock && this.optUp.hasNext) {\n\t\t\tthis.triggerUpScroll();\n\t\t}\n\t}\n}\n\n/*列表滚动事件*/\nMeScroll.prototype.onPageScroll = function() {\n\tconsole.warn('当前版本无需再调用mescroll.onPageScroll(e)'); // 兼容1.0.3以下版本,防止报错\n}\nMeScroll.prototype.scroll = function(e, onScroll) {\n\t// 节流\n\tlet t = new Date().getTime();\n\tif(this.scrollTime && t - this.scrollTime < this.scrollTimeDiff){ // 小于节流时间,则不处理\n\t\treturn;\n\t}else{\n\t\tthis.scrollTime = t\n\t\tthis.scrollTimeDiff = 1000/this.optUp.fps\n\t}\n\t\n\tlet me = this;\n\tlet scrollTop = e.scrollTop;\n\n\t// 顶部按钮的显示隐藏\n\tif (scrollTop > 0 && me.optUp.toTop.src) {\n\t\tif (scrollTop >= me.optUp.toTop.offset) {\n\t\t\tme.showTopBtn();\n\t\t} else {\n\t\t\tme.hideTopBtn();\n\t\t}\n\t}\n\n\t// 滑动监听\n\tif (me.optUp.onScroll && onScroll) {\n\t\t// 向上滑还是向下滑动\n\t\tif (me.preScrollY == null) me.preScrollY = 0;\n\t\tme.isScrollUp = scrollTop - me.preScrollY > 0;\n\t\tme.preScrollY = scrollTop;\n\t\t// 滚动回调\n\t\tonScroll(me, scrollTop, me.isScrollUp);\n\t}\n\n\tme.setScrollTop(scrollTop);\n}\n\n/* 触发上拉加载 */\nMeScroll.prototype.triggerUpScroll = function() {\n\tif (this.optUp.callback && !this.isUpScrolling) {\n\t\tthis.showUpScroll(); // 上拉加载中...\n\t\tthis.optUp.page.num++; // 预先加一页,如果失败则减回\n\t\tthis.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\n\t\tthis.num = this.optUp.page.num; // 把最新的页数赋值在mescroll上,避免对page的影响\n\t\tthis.size = this.optUp.page.size; // 把最新的页码赋值在mescroll上,避免对page的影响\n\t\tthis.time = this.optUp.page.time; // 把最新的页码赋值在mescroll上,避免对page的影响\n\t\tthis.optUp.callback(this); // 执行回调,联网加载数据\n\t}\n}\n\n/* 显示上拉加载中 */\nMeScroll.prototype.showUpScroll = function() {\n\tthis.isUpScrolling = true; // 标记上拉加载中\n\tthis.optUp.showLoading && this.optUp.showLoading(this); // 回调\n}\n\n/* 显示上拉无更多数据 */\nMeScroll.prototype.showNoMore = function() {\n\tthis.optUp.hasNext = false; // 标记无更多数据\n\tthis.optUp.showNoMore && this.optUp.showNoMore(this); // 回调\n}\n\n/* 隐藏上拉区域**/\nMeScroll.prototype.hideUpScroll = function() {\n\tthis.optUp.hideUpScroll && this.optUp.hideUpScroll(this); // 回调\n}\n\n/* 结束上拉加载 */\nMeScroll.prototype.endUpScroll = function(isShowNoMore) {\n\tif (isShowNoMore != null) { // isShowNoMore=null,不处理下拉状态,下拉刷新的时候调用\n\t\tif (isShowNoMore) {\n\t\t\tthis.showNoMore(); // isShowNoMore=true,显示无更多数据\n\t\t} else {\n\t\t\tthis.hideUpScroll(); // isShowNoMore=false,隐藏上拉加载\n\t\t}\n\t}\n\tthis.isUpScrolling = false; // 标记结束上拉加载\n}\n\n/* 重置上拉加载列表为第一页\n *isShowLoading 是否显示进度布局;\n * 1.默认null,不传参,则显示上拉加载的进度布局\n * 2.传参true, 则显示下拉刷新的进度布局\n * 3.传参false,则不显示上拉和下拉的进度 (常用于静默更新列表数据)\n */\nMeScroll.prototype.resetUpScroll = function(isShowLoading) {\n\tif (this.optUp && this.optUp.use) {\n\t\tlet page = this.optUp.page;\n\t\tthis.prePageNum = page.num; // 缓存重置前的页码,加载失败可退回\n\t\tthis.prePageTime = page.time; // 缓存重置前的时间,加载失败可退回\n\t\tpage.num = 1; // 重置为第一页\n\t\tpage.time = null; // 重置时间为空\n\t\tif (!this.isDownScrolling && isShowLoading !== false) { // 如果不是下拉刷新触发的resetUpScroll并且不配置列表静默更新,则显示进度;\n\t\t\tif (isShowLoading == null) {\n\t\t\t\tthis.removeEmpty(); // 移除空布局\n\t\t\t\tthis.showUpScroll(); // 不传参,默认显示上拉加载的进度布局\n\t\t\t} else {\n\t\t\t\tthis.showDownScroll(); // 传true,显示下拉刷新的进度布局,不清空列表\n\t\t\t}\n\t\t}\n\t\tthis.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\n\t\tthis.num = page.num; // 把最新的页数赋值在mescroll上,避免对page的影响\n\t\tthis.size = page.size; // 把最新的页码赋值在mescroll上,避免对page的影响\n\t\tthis.time = page.time; // 把最新的页码赋值在mescroll上,避免对page的影响\n\t\tthis.optUp.callback && this.optUp.callback(this); // 执行上拉回调\n\t}\n}\n\n/* 设置page.num的值 */\nMeScroll.prototype.setPageNum = function(num) {\n\tthis.optUp.page.num = num - 1;\n}\n\n/* 设置page.size的值 */\nMeScroll.prototype.setPageSize = function(size) {\n\tthis.optUp.page.size = size;\n}\n\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据量(必传)\n * totalPage: 总页数(必传)\n * systime: 服务器时间 (可空)\n */\nMeScroll.prototype.endByPage = function(dataSize, totalPage, systime) {\n\tlet hasNext;\n\tif (this.optUp.use && totalPage != null) hasNext = this.optUp.page.num < totalPage; // 是否还有下一页\n\tthis.endSuccess(dataSize, hasNext, systime);\n}\n\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据量(必传)\n * totalSize: 列表所有数据总数量(必传)\n * systime: 服务器时间 (可空)\n */\nMeScroll.prototype.endBySize = function(dataSize, totalSize, systime) {\n\tlet hasNext;\n\tif (this.optUp.use && totalSize != null) {\n\t\tlet loadSize = (this.optUp.page.num - 1) * this.optUp.page.size + dataSize; // 已加载的数据总数\n\t\thasNext = loadSize < totalSize; // 是否还有下一页\n\t}\n\tthis.endSuccess(dataSize, hasNext, systime);\n}\n\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据个数(不是所有页的数据总和),用于上拉加载判断是否还有下一页.如果不传,则会判断还有下一页\n * hasNext: 是否还有下一页,布尔类型;用来解决这个小问题:比如列表共有20条数据,每页加载10条,共2页.如果只根据dataSize判断,则需翻到第三页才会知道无更多数据,如果传了hasNext,则翻到第二页即可显示无更多数据.\n * systime: 服务器时间(可空);用来解决这个小问题:当准备翻下一页时,数据库新增了几条记录,此时翻下一页,前面的几条数据会和上一页的重复;这里传入了systime,那么upCallback的page.time就会有值,把page.time传给服务器,让后台过滤新加入的那几条记录\n */\nMeScroll.prototype.endSuccess = function(dataSize, hasNext, systime) {\n\tlet me = this;\n\t// 结束下拉刷新\n\tif (me.isDownScrolling) me.endDownScroll();\n\n\t// 结束上拉加载\n\tif (me.optUp.use) {\n\t\tlet isShowNoMore; // 是否已无更多数据\n\t\tif (dataSize != null) {\n\t\t\tlet pageNum = me.optUp.page.num; // 当前页码\n\t\t\tlet pageSize = me.optUp.page.size; // 每页长度\n\t\t\t// 如果是第一页\n\t\t\tif (pageNum === 1) {\n\t\t\t\tif (systime) me.optUp.page.time = systime; // 设置加载列表数据第一页的时间\n\t\t\t}\n\t\t\tif (dataSize < pageSize || hasNext === false) {\n\t\t\t\t// 返回的数据不满一页时,则说明已无更多数据\n\t\t\t\tme.optUp.hasNext = false;\n\t\t\t\tif (dataSize === 0 && pageNum === 1) {\n\t\t\t\t\t// 如果第一页无任何数据且配置了空布局\n\t\t\t\t\tisShowNoMore = false;\n\t\t\t\t\tme.showEmpty();\n\t\t\t\t} else {\n\t\t\t\t\t// 总列表数少于配置的数量,则不显示无更多数据\n\t\t\t\t\tlet allDataSize = (pageNum - 1) * pageSize + dataSize;\n\t\t\t\t\tif (allDataSize < me.optUp.noMoreSize) {\n\t\t\t\t\t\tisShowNoMore = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisShowNoMore = true;\n\t\t\t\t\t}\n\t\t\t\t\tme.removeEmpty(); // 移除空布局\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 还有下一页\n\t\t\t\tisShowNoMore = false;\n\t\t\t\tme.optUp.hasNext = true;\n\t\t\t\tme.removeEmpty(); // 移除空布局\n\t\t\t}\n\t\t}\n\n\t\t// 隐藏上拉\n\t\tme.endUpScroll(isShowNoMore);\n\t}\n}\n\n/* 回调失败,结束下拉刷新和上拉加载 */\nMeScroll.prototype.endErr = function() {\n\t// 结束下拉,回调失败重置回原来的页码和时间\n\tif (this.isDownScrolling) {\n\t\tlet page = this.optUp.page;\n\t\tif (page && this.prePageNum) {\n\t\t\tpage.num = this.prePageNum;\n\t\t\tpage.time = this.prePageTime;\n\t\t}\n\t\tthis.endDownScroll();\n\t}\n\t// 结束上拉,回调失败重置回原来的页码\n\tif (this.isUpScrolling) {\n\t\tthis.optUp.page.num--;\n\t\tthis.endUpScroll(false);\n\t\tthis.scrollTo(this.getScrollTop() - 1, 0) // 往上回滚1px,使其能够再次触发scrolltolower\n\t}\n}\n\n/* 显示空布局 */\nMeScroll.prototype.showEmpty = function() {\n\tthis.optUp.empty.use && this.optUp.empty.onShow && this.optUp.empty.onShow(true)\n}\n\n/* 移除空布局 */\nMeScroll.prototype.removeEmpty = function() {\n\tthis.optUp.empty.onShow && this.optUp.empty.onShow(false)\n}\n\n/* 显示回到顶部的按钮 */\nMeScroll.prototype.showTopBtn = function() {\n\tif (this.optUp.toTop.src && !this.topBtnShow) {\n\t\tthis.topBtnShow = true;\n\t\tthis.optUp.toTop.onShow && this.optUp.toTop.onShow(true);\n\t}\n}\n\n/* 隐藏回到顶部的按钮 */\nMeScroll.prototype.hideTopBtn = function() {\n\tif (this.optUp.toTop.src && this.topBtnShow) {\n\t\tthis.topBtnShow = false;\n\t\tthis.optUp.toTop.onShow && this.optUp.toTop.onShow(false);\n\t}\n}\n\n/* 获取滚动条的位置 */\nMeScroll.prototype.getScrollTop = function() {\n\treturn this.scrollTop || 0\n}\n\n/* 记录滚动条的位置 */\nMeScroll.prototype.setScrollTop = function(y) {\n\tthis.scrollTop = y;\n}\n\n/* 滚动到指定位置 */\nMeScroll.prototype.scrollTo = function(y, t) {\n\tthis.myScrollTo&&this.myScrollTo(y, t) // scrollview需自定义回到顶部方法\n}\n\n/* 自定义scrollTo */\nMeScroll.prototype.resetScrollTo = function(myScrollTo) {\n\tthis.myScrollTo = myScrollTo\n}\n\n/* 计步器\n star: 开始值\n end: 结束值\n callback(step,timer): 回调step值,计步器timer,可自行通过window.clearInterval(timer)结束计步器;\n t: 计步时长,传0则直接回调end值;不传则默认300ms\n rate: 周期;不传则默认30ms计步一次\n * */\nMeScroll.prototype.getStep = function(star, end, callback, t, rate) {\n\tlet diff = end - star; // 差值\n\tif (t === 0 || diff === 0) {\n\t\tcallback && callback(end);\n\t\treturn;\n\t}\n\tt = t || 300; // 时长 300ms\n\trate = rate || 30; // 周期 30ms\n\tlet count = t / rate; // 次数\n\tlet step = diff / count; // 步长\n\tlet i = 0; // 计数\n\tlet timer = setInterval(function() {\n\t\tif (i < count - 1) {\n\t\t\tstar += step;\n\t\t\tcallback && callback(star, timer);\n\t\t\ti++;\n\t\t} else {\n\t\t\tcallback && callback(end, timer); // 最后一次直接设置end,避免计算误差\n\t\t\tclearInterval(timer);\n\t\t}\n\t}, rate);\n}\n\n/* body的高度 */\nMeScroll.prototype.getBodyHeight = function() {\n\treturn this.bodyHeight || 0;\n}\n\nMeScroll.prototype.setBodyHeight = function(h) {\n\tthis.bodyHeight = h;\n}\n\n/* 阻止浏览器默认滚动事件 */\nMeScroll.prototype.preventDefault = function(e) {\n\t// cancelable:是否可以被禁用; defaultPrevented:是否已经被禁用\n\t// if (e && e.cancelable && !e.defaultPrevented) e.preventDefault()\n\t// 只能通过配置pages.json的style.app-plus.bounce为\"none\"来禁止app的bounce\n\te && e.preventDefault()\n}\n"]}]}