{"remainingRequest":"/Users/lee/Desktop/github/mall-project/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js!/Users/lee/Desktop/github/mall-project/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader/index.js??ref--12-2!/Users/lee/Desktop/github/mall-project/src/components/mescroll-uni/mescroll-uni.js","dependencies":[{"path":"/Users/lee/Desktop/github/mall-project/src/components/mescroll-uni/mescroll-uni.js","mtime":1566611884969},{"path":"/Users/lee/Desktop/github/mall-project/node_modules/cache-loader/dist/cjs.js","mtime":1554990705312},{"path":"/Users/lee/Desktop/github/mall-project/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js","mtime":1560261191357},{"path":"/Users/lee/Desktop/github/mall-project/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader/index.js","mtime":1563798331564}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = MeScroll;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* mescroll-uni\n * version 1.1.5\n * 2019-07-25 wenju\n * https://github.com/leoxiaoge/mescroll\n */\nfunction MeScroll(options) {\n  var me = this;\n  me.version = '1.1.5'; // mescroll版本号\n\n  me.options = options || {}; // 配置\n\n  me.isDownScrolling = false; // 是否在执行下拉刷新的回调\n\n  me.isUpScrolling = false; // 是否在执行上拉加载的回调\n\n  var hasDownCallback = me.options.down && me.options.down.callback; // 是否配置了down的callback\n  // 初始化下拉刷新\n\n  me.initDownScroll(); // 初始化上拉加载,则初始化\n\n  me.initUpScroll(); // 自动加载\n\n  setTimeout(function () {\n    // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n    // 自动触发下拉刷新 (只有配置了down的callback才自动触发下拉刷新)\n    if (me.optDown.use && me.optDown.auto && hasDownCallback) {\n      if (me.optDown.autoShowLoading) {\n        me.triggerDownScroll(); // 显示下拉进度,执行下拉回调\n      } else {\n        me.optDown.callback && me.optDown.callback(me); // 不显示下拉进度,直接执行下拉回调\n      }\n    } // 自动触发上拉加载\n\n\n    me.optUp.use && me.optUp.auto && !me.isUpAutoLoad && me.triggerUpScroll();\n  }, 30); // 需让me.optDown.inited和me.optUp.inited先执行\n}\n/* 配置参数:下拉刷新 */\n\n\nMeScroll.prototype.extendDownScroll = function (optDown) {\n  // 下拉刷新的配置\n  MeScroll.extend(optDown, {\n    use: true,\n    // 是否启用下拉刷新; 默认true\n    auto: true,\n    // 是否在初始化完毕之后自动执行下拉刷新的回调; 默认true\n    autoShowLoading: false,\n    // 如果设置auto=true(在初始化完毕之后自动执行下拉刷新的回调),那么是否显示下拉刷新的进度; 默认false\n    isLock: false,\n    // 是否锁定下拉刷新,默认false;\n    offset: 80,\n    // 在列表顶部,下拉大于80px,松手即可触发下拉刷新的回调\n    startTop: 100,\n    // scroll-view滚动到顶部时,此时的scroll-top不一定为0, 此值用于控制最大的误差\n    fps: 40,\n    // 下拉节流 (值越大每秒刷新频率越高)\n    supply: 200,\n    // 补帧动画的过渡时长 (只对android小程序生效,用于解决android小程序下拉卡顿的问题)\n    inOffsetRate: 1,\n    // 在列表顶部,下拉的距离小于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\n    outOffsetRate: 0.2,\n    // 在列表顶部,下拉的距离大于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\n    bottomOffset: 20,\n    // 当手指touchmove位置在距离body底部20px范围内的时候结束上拉刷新,避免Webview嵌套导致touchend事件不执行\n    minAngle: 45,\n    // 向下滑动最少偏移的角度,取值区间  [0,90];默认45度,即向下滑动的角度大于45度则触发下拉;而小于45度,将不触发下拉,避免与左右滑动的轮播等组件冲突;\n    textInOffset: '下拉刷新',\n    // 下拉的距离在offset范围内的提示文本\n    textOutOffset: '释放更新',\n    // 下拉的距离大于offset范围的提示文本\n    textLoading: '加载中 ...',\n    // 加载中的提示文本\n    inited: null,\n    // 下拉刷新初始化完毕的回调\n    inOffset: null,\n    // 下拉的距离进入offset范围内那一刻的回调\n    outOffset: null,\n    // 下拉的距离大于offset那一刻的回调\n    onMoving: null,\n    // 下拉过程中的回调,滑动过程一直在执行; rate下拉区域当前高度与指定距离的比值(inOffset: rate<1; outOffset: rate>=1); downHight当前下拉区域的高度\n    beforeLoading: null,\n    // 准备触发下拉刷新的回调: 如果return true,将不触发showLoading和callback回调; 常用来完全自定义下拉刷新, 参考案例【淘宝 v6.8.0】\n    showLoading: null,\n    // 显示下拉刷新进度的回调\n    afterLoading: null,\n    // 准备结束下拉的回调. 返回结束下拉的延时执行时间,默认0ms; 常用于结束下拉之前再显示另外一小段动画,才去隐藏下拉刷新的场景, 参考案例【dotJump】\n    endDownScroll: null,\n    // 结束下拉刷新的回调\n    callback: function callback(mescroll) {\n      // 下拉刷新的回调;默认重置上拉加载列表为第一页\n      mescroll.resetUpScroll();\n    }\n  });\n};\n/* 配置参数:上拉加载 */\n\n\nMeScroll.prototype.extendUpScroll = function (optUp) {\n  // 上拉加载的配置\n  MeScroll.extend(optUp, {\n    use: true,\n    // 是否启用上拉加载; 默认true\n    auto: true,\n    // 是否在初始化完毕之后自动执行上拉加载的回调; 默认true\n    isLock: false,\n    // 是否锁定上拉加载,默认false;\n    isBoth: true,\n    // 上拉加载时,如果滑动到列表顶部是否可以同时触发下拉刷新;默认true,两者可同时触发;\n    isBounce: false,\n    // 默认禁止橡皮筋的回弹效果, 必读事项: http://www.mescroll.com/qa.html?v=190725#q25\n    callback: null,\n    // 上拉加载的回调;function(page,mescroll){ }\n    page: {\n      num: 0,\n      // 当前页码,默认0,回调之前会加1,即callback(page)会从1开始\n      size: 10,\n      // 每页数据的数量\n      time: null // 加载第一页数据服务器返回的时间; 防止用户翻页时,后台新增了数据从而导致下一页数据重复;\n\n    },\n    noMoreSize: 5,\n    // 如果列表已无数据,可设置列表的总数量要大于等于5条才显示无更多数据;避免列表数据过少(比如只有一条数据),显示无更多数据会不好看\n    offset: 80,\n    // 距底部多远时,触发upCallback\n    textLoading: '加载中 ...',\n    // 加载中的提示文本\n    textNoMore: '-- END --',\n    // 没有更多数据的提示文本\n    inited: null,\n    // 初始化完毕的回调\n    showLoading: null,\n    // 显示加载中的回调\n    showNoMore: null,\n    // 显示无更多数据的回调\n    hideUpScroll: null,\n    // 隐藏上拉加载的回调\n    toTop: {\n      // 回到顶部按钮,需配置src才显示\n      src: null,\n      // 图片路径,默认null (建议写成网络图,不必考虑相对路径)\n      offset: 1000,\n      // 列表滚动多少距离才显示回到顶部按钮,默认1000\n      duration: 300,\n      // 回到顶部的动画时长,默认300ms\n      btnClick: null,\n      // 点击按钮的回调\n      onShow: null // 是否显示的回调\n\n    },\n    empty: {\n      use: true,\n      // 是否显示空布局\n      icon: null,\n      // 图标路径\n      tip: '~ 暂无相关数据 ~',\n      // 提示\n      btnText: '',\n      // 按钮\n      btnClick: null,\n      // 点击按钮的回调\n      onShow: null // 是否显示的回调\n\n    },\n    onScroll: false // 是否监听滚动事件\n\n  });\n};\n/* 配置参数 */\n\n\nMeScroll.extend = function (userOption, defaultOption) {\n  if (!userOption) return defaultOption;\n\n  for (var key in defaultOption) {\n    if (userOption[key] == null) {\n      var def = defaultOption[key];\n\n      if (def != null && _typeof(def) === 'object') {\n        userOption[key] = MeScroll.extend({}, def); // 深度匹配\n      } else {\n        userOption[key] = def;\n      }\n    } else if (_typeof(userOption[key]) === 'object') {\n      MeScroll.extend(userOption[key], defaultOption[key]); // 深度匹配\n    }\n  }\n\n  return userOption;\n};\n/* -------初始化下拉刷新------- */\n\n\nMeScroll.prototype.initDownScroll = function () {\n  var me = this; // 配置参数\n\n  me.optDown = me.options.down || {};\n  me.extendDownScroll(me.optDown);\n  me.downHight = 0; // 下拉区域的高度\n  // 在页面中加入下拉布局\n\n  if (me.optDown.use && me.optDown.inited) {\n    // 初始化完毕的回调\n    setTimeout(function () {\n      // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n      me.optDown.inited(me);\n    }, 0);\n  }\n};\n/* 列表touchstart事件 */\n\n\nMeScroll.prototype.touchstartEvent = function (e) {\n  if (!this.optDown.use) return;\n  this.startPoint = this.getPoint(e); // 记录起点\n\n  this.startTop = this.getScrollTop(); // 记录此时的滚动条位置\n\n  this.lastPoint = this.startPoint; // 重置上次move的点\n\n  this.maxTouchmoveY = this.getBodyHeight() - this.optDown.bottomOffset; // 手指触摸的最大范围(写在touchstart避免body获取高度为0的情况)\n\n  this.inTouchend = false; // 标记不是touchend\n};\n/* 列表touchmove事件 */\n\n\nMeScroll.prototype.touchmoveEvent = function (e) {\n  if (!this.optDown.use) return;\n  if (!this.startPoint) return;\n  var me = this; // 节流\n\n  var t = new Date().getTime();\n\n  if (me.moveTime && t - me.moveTime < me.moveTimeDiff) {\n    // 小于节流时间,则不处理\n    return;\n  } else {\n    me.moveTime = t;\n    me.moveTimeDiff = 1000 / me.optDown.fps;\n  }\n\n  var scrollTop = me.getScrollTop(); // 当前滚动条的距离\n\n  var curPoint = me.getPoint(e); // 当前点\n\n  var moveY = curPoint.y - me.startPoint.y; // 和起点比,移动的距离,大于0向下拉,小于0向上拉\n  // (向下拉&&在顶部) scroll-view在滚动时不会触发touchmove,当触顶/底/左/右时,才会触发touchmove\n  // scroll-view滚动到顶部时,scrollTop不一定为0; 在iOS的APP中scrollTop可能为负数,不一定和startTop相等\n\n  if (moveY > 0 && (scrollTop <= 0 || scrollTop <= me.optDown.startTop && scrollTop === me.startTop)) {\n    // 可下拉的条件\n    if (me.optDown.use && !me.inTouchend && !me.isDownScrolling && !me.optDown.isLock && (!me.isUpScrolling || me.isUpScrolling && me.optUp.isBoth)) {\n      // 下拉的角度是否在配置的范围内\n      var x = Math.abs(me.lastPoint.x - curPoint.x);\n      var y = Math.abs(me.lastPoint.y - curPoint.y);\n      var z = Math.sqrt(x * x + y * y);\n\n      if (z !== 0) {\n        var angle = Math.asin(y / z) / Math.PI * 180; // 两点之间的角度,区间 [0,90]\n\n        if (angle < me.optDown.minAngle) return; // 如果小于配置的角度,则不往下执行下拉刷新\n      } // 如果手指的位置超过配置的距离,则提前结束下拉,避免Webview嵌套导致touchend无法触发\n\n\n      if (me.maxTouchmoveY > 0 && curPoint.y >= me.maxTouchmoveY) {\n        me.inTouchend = true; // 标记执行touchend\n\n        me.touchendEvent(); // 提前触发touchend\n\n        return;\n      }\n\n      me.preventDefault(e); // 阻止默认事件\n\n      var diff = curPoint.y - me.lastPoint.y; // 和上次比,移动的距离 (大于0向下,小于0向上)\n      // 下拉距离  < 指定距离\n\n      if (me.downHight < me.optDown.offset) {\n        if (me.movetype !== 1) {\n          me.movetype = 1; // 加入标记,保证只执行一次\n\n          me.optDown.inOffset && me.optDown.inOffset(me); // 进入指定距离范围内那一刻的回调,只执行一次\n\n          me.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\n        }\n\n        me.downHight += diff * me.optDown.inOffsetRate; // 越往下,高度变化越小\n        // 指定距离  <= 下拉距离\n      } else {\n        if (me.movetype !== 2) {\n          me.movetype = 2; // 加入标记,保证只执行一次\n\n          me.optDown.outOffset && me.optDown.outOffset(me); // 下拉超过指定距离那一刻的回调,只执行一次\n\n          me.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\n        }\n\n        if (diff > 0) {\n          // 向下拉\n          me.downHight += Math.round(diff * me.optDown.outOffsetRate); // 越往下,高度变化越小\n        } else {\n          // 向上收\n          me.downHight += diff; // 向上收回高度,则向上滑多少收多少高度\n        }\n      }\n\n      var rate = me.downHight / me.optDown.offset; // 下拉区域当前高度与指定距离的比值\n\n      me.optDown.onMoving && me.optDown.onMoving(me, rate, me.downHight); // 下拉过程中的回调,一直在执行\n    }\n  }\n\n  me.lastPoint = curPoint; // 记录本次移动的点\n};\n/* 列表touchend事件 */\n\n\nMeScroll.prototype.touchendEvent = function (e) {\n  if (!this.optDown.use) return; // 如果下拉区域高度已改变,则需重置回来\n\n  if (this.isMoveDown) {\n    if (this.downHight >= this.optDown.offset) {\n      // 符合触发刷新的条件\n      this.triggerDownScroll();\n    } else {\n      // 不符合的话 则重置\n      this.downHight = 0;\n      this.optDown.endDownScroll && this.optDown.endDownScroll(this);\n    }\n\n    this.movetype = 0;\n    this.isMoveDown = false;\n  } else if (this.getScrollTop() === this.startTop) {\n    // 到顶/左/右/底的滑动事件\n    var isScrollUp = this.getPoint(e).y - this.startPoint.y < 0; // 和起点比,移动的距离,大于0向下拉,小于0向上拉\n    // 上滑 && 检查并触发上拉\n\n    isScrollUp && this.triggerUpScroll(true);\n  }\n};\n/* 根据点击滑动事件获取第一个手指的坐标 */\n\n\nMeScroll.prototype.getPoint = function (e) {\n  if (e.touches && e.touches[0]) {\n    return {\n      x: e.touches[0].pageX,\n      y: e.touches[0].pageY\n    };\n  } else if (e.changedTouches && e.changedTouches[0]) {\n    return {\n      x: e.changedTouches[0].pageX,\n      y: e.changedTouches[0].pageY\n    };\n  } else {\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n};\n/* 触发下拉刷新 */\n\n\nMeScroll.prototype.triggerDownScroll = function () {\n  if (this.optDown.beforeLoading && this.optDown.beforeLoading(this)) {//return true则处于完全自定义状态\n  } else {\n    this.showDownScroll(); // 下拉刷新中...\n\n    this.optDown.callback && this.optDown.callback(this); // 执行回调,联网加载数据\n  }\n};\n/* 显示下拉进度布局 */\n\n\nMeScroll.prototype.showDownScroll = function () {\n  this.isDownScrolling = true; // 标记下拉中\n\n  this.downHight = this.optDown.offset; // 更新下拉区域高度\n\n  this.optDown.showLoading(this, this.downHight); // 下拉刷新中...\n};\n/* 结束下拉刷新 */\n\n\nMeScroll.prototype.endDownScroll = function () {\n  var me = this; // 结束下拉刷新的方法\n\n  var endScroll = function endScroll() {\n    me.downHight = 0;\n    me.isDownScrolling = false;\n    me.optDown.endDownScroll && me.optDown.endDownScroll(me);\n  }; // 结束下拉刷新时的回调\n\n\n  var delay = 0;\n  if (me.optDown.afterLoading) delay = me.optDown.afterLoading(me); // 结束下拉刷新的延时,单位ms\n\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(endScroll, delay);\n  } else {\n    endScroll();\n  }\n};\n/* 锁定下拉刷新:isLock=ture,null锁定;isLock=false解锁 */\n\n\nMeScroll.prototype.lockDownScroll = function (isLock) {\n  if (isLock == null) isLock = true;\n  this.optDown.isLock = isLock;\n};\n/* -------初始化上拉加载------- */\n\n\nMeScroll.prototype.initUpScroll = function () {\n  var me = this; // 配置参数\n\n  me.optUp = me.options.up || {\n    use: false\n  };\n  me.extendUpScroll(me.optUp);\n  if (!me.optUp.isBounce) me.setBounce(false); // 不允许bounce时,需禁止window的touchmove事件\n\n  if (me.optUp.use === false) return; // 配置不使用上拉加载时,则不初始化上拉布局\n\n  me.optUp.hasNext = true; // 如果使用上拉,则默认有下一页\n\n  me.startNum = me.optUp.page.num + 1; // 记录page开始的页码\n  // 初始化完毕的回调\n\n  if (me.optUp.inited) {\n    setTimeout(function () {\n      // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n      me.optUp.inited(me);\n    }, 0);\n  }\n};\n/*列表滚动事件*/\n\n\nMeScroll.prototype.scroll = function (e, onScroll) {\n  // 更新滚动条的位置\n  this.setScrollTop(e.scrollTop); // 更新滚动内容高度\n\n  this.setScrollHeight(e.scrollHeight); // 向上滑还是向下滑动\n\n  if (this.preScrollY == null) this.preScrollY = 0;\n  this.isScrollUp = e.scrollTop - this.preScrollY > 0;\n  this.preScrollY = e.scrollTop; // 上滑 && 检查并触发上拉\n\n  this.isScrollUp && this.triggerUpScroll(true); // 顶部按钮的显示隐藏\n\n  if (e.scrollTop >= this.optUp.toTop.offset) {\n    this.showTopBtn();\n  } else {\n    this.hideTopBtn();\n  } // 滑动监听\n\n\n  this.optUp.onScroll && onScroll && onScroll();\n};\n/* 触发上拉加载 */\n\n\nMeScroll.prototype.triggerUpScroll = function (isCheck) {\n  if (!this.isUpScrolling && this.optUp.use && this.optUp.callback) {\n    // 是否校验在底部; 默认不校验\n    if (isCheck === true) {\n      var canUp = false; // 还有下一页 && 没有锁定 && (不在下拉中 || 支持同时上下拉)\n\n      if (this.optUp.hasNext && !this.optUp.isLock && !this.isDownScrolling) {\n        if (this.getScrollBottom() <= this.optUp.offset) {\n          // 到底部\n          canUp = true; // 标记可上拉\n        }\n      }\n\n      if (canUp === false) return;\n    }\n\n    this.showUpScroll(); // 上拉加载中...\n\n    this.optUp.page.num++; // 预先加一页,如果失败则减回\n\n    this.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\n\n    this.num = this.optUp.page.num; // 把最新的页数赋值在mescroll上,避免对page的影响\n\n    this.size = this.optUp.page.size; // 把最新的页码赋值在mescroll上,避免对page的影响\n\n    this.time = this.optUp.page.time; // 把最新的页码赋值在mescroll上,避免对page的影响\n\n    this.optUp.callback(this); // 执行回调,联网加载数据\n  }\n};\n/* 显示上拉加载中 */\n\n\nMeScroll.prototype.showUpScroll = function () {\n  this.isUpScrolling = true; // 标记上拉加载中\n\n  this.optUp.showLoading && this.optUp.showLoading(this); // 回调\n};\n/* 显示上拉无更多数据 */\n\n\nMeScroll.prototype.showNoMore = function () {\n  this.optUp.hasNext = false; // 标记无更多数据\n\n  this.optUp.showNoMore && this.optUp.showNoMore(this); // 回调\n};\n/* 隐藏上拉区域**/\n\n\nMeScroll.prototype.hideUpScroll = function () {\n  this.optUp.hideUpScroll && this.optUp.hideUpScroll(this); // 回调\n};\n/* 结束上拉加载 */\n\n\nMeScroll.prototype.endUpScroll = function (isShowNoMore) {\n  if (isShowNoMore != null) {\n    // isShowNoMore=null,不处理下拉状态,下拉刷新的时候调用\n    if (isShowNoMore) {\n      this.showNoMore(); // isShowNoMore=true,显示无更多数据\n    } else {\n      this.hideUpScroll(); // isShowNoMore=false,隐藏上拉加载\n    }\n  }\n\n  this.isUpScrolling = false; // 标记结束上拉加载\n};\n/* 重置上拉加载列表为第一页\n *isShowLoading 是否显示进度布局;\n * 1.默认null,不传参,则显示上拉加载的进度布局\n * 2.传参true, 则显示下拉刷新的进度布局\n * 3.传参false,则不显示上拉和下拉的进度 (常用于静默更新列表数据)\n */\n\n\nMeScroll.prototype.resetUpScroll = function (isShowLoading) {\n  if (this.optUp && this.optUp.use) {\n    var page = this.optUp.page;\n    this.prePageNum = page.num; // 缓存重置前的页码,加载失败可退回\n\n    this.prePageTime = page.time; // 缓存重置前的时间,加载失败可退回\n\n    page.num = this.startNum; // 重置为第一页\n\n    page.time = null; // 重置时间为空\n\n    if (!this.isDownScrolling && isShowLoading !== false) {\n      // 如果不是下拉刷新触发的resetUpScroll并且不配置列表静默更新,则显示进度;\n      if (isShowLoading == null) {\n        this.removeEmpty(); // 移除空布局\n\n        this.showUpScroll(); // 不传参,默认显示上拉加载的进度布局\n      } else {\n        this.showDownScroll(); // 传true,显示下拉刷新的进度布局,不清空列表\n      }\n    }\n\n    this.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\n\n    this.num = page.num; // 把最新的页数赋值在mescroll上,避免对page的影响\n\n    this.size = page.size; // 把最新的页码赋值在mescroll上,避免对page的影响\n\n    this.time = page.time; // 把最新的页码赋值在mescroll上,避免对page的影响\n\n    this.optUp.callback && this.optUp.callback(this); // 执行上拉回调\n  }\n};\n/* 设置page.num的值 */\n\n\nMeScroll.prototype.setPageNum = function (num) {\n  this.optUp.page.num = num - 1;\n};\n/* 设置page.size的值 */\n\n\nMeScroll.prototype.setPageSize = function (size) {\n  this.optUp.page.size = size;\n};\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据量(必传)\n * totalPage: 总页数(必传)\n * systime: 服务器时间 (可空)\n */\n\n\nMeScroll.prototype.endByPage = function (dataSize, totalPage, systime) {\n  var hasNext;\n  if (this.optUp.use && totalPage != null) hasNext = this.optUp.page.num < totalPage; // 是否还有下一页\n\n  this.endSuccess(dataSize, hasNext, systime);\n};\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据量(必传)\n * totalSize: 列表所有数据总数量(必传)\n * systime: 服务器时间 (可空)\n */\n\n\nMeScroll.prototype.endBySize = function (dataSize, totalSize, systime) {\n  var hasNext;\n\n  if (this.optUp.use && totalSize != null) {\n    var loadSize = (this.optUp.page.num - 1) * this.optUp.page.size + dataSize; // 已加载的数据总数\n\n    hasNext = loadSize < totalSize; // 是否还有下一页\n  }\n\n  this.endSuccess(dataSize, hasNext, systime);\n};\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据个数(不是所有页的数据总和),用于上拉加载判断是否还有下一页.如果不传,则会判断还有下一页\n * hasNext: 是否还有下一页,布尔类型;用来解决这个小问题:比如列表共有20条数据,每页加载10条,共2页.如果只根据dataSize判断,则需翻到第三页才会知道无更多数据,如果传了hasNext,则翻到第二页即可显示无更多数据.\n * systime: 服务器时间(可空);用来解决这个小问题:当准备翻下一页时,数据库新增了几条记录,此时翻下一页,前面的几条数据会和上一页的重复;这里传入了systime,那么upCallback的page.time就会有值,把page.time传给服务器,让后台过滤新加入的那几条记录\n */\n\n\nMeScroll.prototype.endSuccess = function (dataSize, hasNext, systime) {\n  var me = this; // 结束下拉刷新\n\n  if (me.isDownScrolling) me.endDownScroll(); // 结束上拉加载\n\n  if (me.optUp.use) {\n    var isShowNoMore; // 是否已无更多数据\n\n    if (dataSize != null) {\n      var pageNum = me.optUp.page.num; // 当前页码\n\n      var pageSize = me.optUp.page.size; // 每页长度\n      // 如果是第一页\n\n      if (pageNum === 1) {\n        if (systime) me.optUp.page.time = systime; // 设置加载列表数据第一页的时间\n      }\n\n      if (dataSize < pageSize || hasNext === false) {\n        // 返回的数据不满一页时,则说明已无更多数据\n        me.optUp.hasNext = false;\n\n        if (dataSize === 0 && pageNum === 1) {\n          // 如果第一页无任何数据且配置了空布局\n          isShowNoMore = false;\n          me.showEmpty();\n        } else {\n          // 总列表数少于配置的数量,则不显示无更多数据\n          var allDataSize = (pageNum - 1) * pageSize + dataSize;\n\n          if (allDataSize < me.optUp.noMoreSize) {\n            isShowNoMore = false;\n          } else {\n            isShowNoMore = true;\n          }\n\n          me.removeEmpty(); // 移除空布局\n        }\n      } else {\n        // 还有下一页\n        isShowNoMore = false;\n        me.optUp.hasNext = true;\n        me.removeEmpty(); // 移除空布局\n      }\n    } // 隐藏上拉\n\n\n    me.endUpScroll(isShowNoMore);\n  }\n};\n/* 回调失败,结束下拉刷新和上拉加载 */\n\n\nMeScroll.prototype.endErr = function () {\n  // 结束下拉,回调失败重置回原来的页码和时间\n  if (this.isDownScrolling) {\n    var page = this.optUp.page;\n\n    if (page && this.prePageNum) {\n      page.num = this.prePageNum;\n      page.time = this.prePageTime;\n    }\n\n    this.endDownScroll();\n  } // 结束上拉,回调失败重置回原来的页码\n\n\n  if (this.isUpScrolling) {\n    this.optUp.page.num--;\n    this.endUpScroll(false);\n  }\n};\n/* 显示空布局 */\n\n\nMeScroll.prototype.showEmpty = function () {\n  this.optUp.empty.use && this.optUp.empty.onShow && this.optUp.empty.onShow(true);\n};\n/* 移除空布局 */\n\n\nMeScroll.prototype.removeEmpty = function () {\n  this.optUp.empty.use && this.optUp.empty.onShow && this.optUp.empty.onShow(false);\n};\n/* 显示回到顶部的按钮 */\n\n\nMeScroll.prototype.showTopBtn = function () {\n  if (!this.topBtnShow) {\n    this.topBtnShow = true;\n    this.optUp.toTop.onShow && this.optUp.toTop.onShow(true);\n  }\n};\n/* 隐藏回到顶部的按钮 */\n\n\nMeScroll.prototype.hideTopBtn = function () {\n  if (this.topBtnShow) {\n    this.topBtnShow = false;\n    this.optUp.toTop.onShow && this.optUp.toTop.onShow(false);\n  }\n};\n/* 获取滚动条的位置 */\n\n\nMeScroll.prototype.getScrollTop = function () {\n  return this.scrollTop || 0;\n};\n/* 记录滚动条的位置 */\n\n\nMeScroll.prototype.setScrollTop = function (y) {\n  this.scrollTop = y;\n};\n/* 滚动到指定位置 */\n\n\nMeScroll.prototype.scrollTo = function (y, t) {\n  this.myScrollTo && this.myScrollTo(y, t); // scrollview需自定义回到顶部方法\n};\n/* 自定义scrollTo */\n\n\nMeScroll.prototype.resetScrollTo = function (myScrollTo) {\n  this.myScrollTo = myScrollTo;\n};\n/* 滚动条到底部的距离 */\n\n\nMeScroll.prototype.getScrollBottom = function () {\n  return this.getScrollHeight() - this.getClientHeight() - this.getScrollTop();\n};\n/* 计步器\n star: 开始值\n end: 结束值\n callback(step,timer): 回调step值,计步器timer,可自行通过window.clearInterval(timer)结束计步器;\n t: 计步时长,传0则直接回调end值;不传则默认300ms\n rate: 周期;不传则默认30ms计步一次\n * */\n\n\nMeScroll.prototype.getStep = function (star, end, callback, t, rate) {\n  var diff = end - star; // 差值\n\n  if (t === 0 || diff === 0) {\n    callback && callback(end);\n    return;\n  }\n\n  t = t || 300; // 时长 300ms\n\n  rate = rate || 30; // 周期 30ms\n\n  var count = t / rate; // 次数\n\n  var step = diff / count; // 步长\n\n  var i = 0; // 计数\n\n  var timer = setInterval(function () {\n    if (i < count - 1) {\n      star += step;\n      callback && callback(star, timer);\n      i++;\n    } else {\n      callback && callback(end, timer); // 最后一次直接设置end,避免计算误差\n\n      clearInterval(timer);\n    }\n  }, rate);\n};\n/* 滚动容器的高度 */\n\n\nMeScroll.prototype.getClientHeight = function (isReal) {\n  var h = this.clientHeight || 0;\n\n  if (h === 0 && isReal !== true) {\n    // 未获取到容器的高度,可临时取body的高度 (可能会有误差)\n    h = this.getBodyHeight();\n  }\n\n  return h;\n};\n\nMeScroll.prototype.setClientHeight = function (h) {\n  this.clientHeight = h;\n};\n/* 滚动内容的高度 */\n\n\nMeScroll.prototype.getScrollHeight = function () {\n  return this.scrollHeight || 0;\n};\n\nMeScroll.prototype.setScrollHeight = function (h) {\n  this.scrollHeight = h;\n};\n/* body的高度 */\n\n\nMeScroll.prototype.getBodyHeight = function () {\n  return this.bodyHeight || 0;\n};\n\nMeScroll.prototype.setBodyHeight = function (h) {\n  this.bodyHeight = h;\n};\n/* 阻止浏览器默认滚动事件 */\n\n\nMeScroll.prototype.preventDefault = function (e) {\n  // 小程序不支持e.preventDefault\n  // app的bounce只能通过配置pages.json的style.app-plus.bounce为\"none\"来禁止\n  // cancelable:是否可以被禁用; defaultPrevented:是否已经被禁用\n  if (e && e.cancelable && !e.defaultPrevented) e.preventDefault();\n};\n/* 是否允许下拉回弹(橡皮筋效果); true或null为允许; false禁止bounce */\n\n\nMeScroll.prototype.setBounce = function (isBounce) {\n  if (isBounce === false) {\n    this.optUp.isBounce = false; // 禁止\n    // 标记当前页使用了mescroll (需延时,确保page已切换)\n\n    setTimeout(function () {\n      var uniPageDom = document.getElementsByTagName('uni-page')[0];\n      uniPageDom && uniPageDom.setAttribute('use_mescroll', true);\n    }, 30); // 避免重复添加事件\n\n    if (window.isSetBounce) return;\n    window.isSetBounce = true; // 需禁止window的touchmove事件才能有效的阻止bounce\n\n    window.bounceTouchmove = function (e) {\n      var el = e.target; // 当前touch的元素及父元素是否要拦截touchmove事件\n\n      var isPrevent = true;\n\n      while (el !== document.body && el !== document) {\n        if (el.tagName === 'UNI-PAGE') {\n          // 只扫描当前页\n          if (!el.getAttribute('use_mescroll')) {\n            isPrevent = false; // 如果当前页没有使用mescroll,则不阻止\n          }\n\n          break;\n        }\n\n        var cls = el.classList;\n\n        if (cls) {\n          if (cls.contains('mescroll-touch')) {\n            // 采用scroll-view 此处不能过滤mescroll-uni,否则下拉仍然有回弹\n            isPrevent = false; // mescroll-touch无需拦截touchmove事件\n\n            break;\n          } else if (cls.contains('mescroll-touch-x') || cls.contains('mescroll-touch-y')) {\n            // 如果配置了水平或者垂直滑动\n            var curX = e.touches ? e.touches[0].pageX : e.clientX; // 当前第一个手指距离列表顶部的距离x\n\n            var curY = e.touches ? e.touches[0].pageY : e.clientY; // 当前第一个手指距离列表顶部的距离y\n\n            if (!this.preWinX) this.preWinX = curX; // 设置上次移动的距离x\n\n            if (!this.preWinY) this.preWinY = curY; // 设置上次移动的距离y\n            // 计算两点之间的角度\n\n            var x = Math.abs(this.preWinX - curX);\n            var y = Math.abs(this.preWinY - curY);\n            var z = Math.sqrt(x * x + y * y);\n            this.preWinX = curX; // 记录本次curX的值\n\n            this.preWinY = curY; // 记录本次curY的值\n\n            if (z !== 0) {\n              var angle = Math.asin(y / z) / Math.PI * 180; // 角度区间 [0,90]\n\n              if (angle <= 45 && cls.contains('mescroll-touch-x') || angle > 45 && cls.contains('mescroll-touch-y')) {\n                isPrevent = false; // 水平滑动或者垂直滑动,不拦截touchmove事件\n\n                break;\n              }\n            }\n          }\n        }\n\n        el = el.parentNode; // 继续检查其父元素\n      } // 拦截touchmove事件:是否可以被禁用&&是否已经被禁用 (这里不使用me.preventDefault(e)的方法,因为某些情况下会报找不到方法的异常)\n\n\n      if (isPrevent && e.cancelable && !e.defaultPrevented && typeof e.preventDefault === \"function\") e.preventDefault();\n    };\n\n    window.addEventListener('touchmove', window.bounceTouchmove, {\n      passive: false\n    });\n  } else {\n    this.optUp.isBounce = true; // 允许\n\n    if (window.bounceTouchmove) {\n      window.removeEventListener('touchmove', window.bounceTouchmove);\n      window.bounceTouchmove = null;\n      window.isSetBounce = false;\n    }\n  }\n};",{"version":3,"sources":["/Users/lee/Desktop/github/mall-project/src/components/mescroll-uni/mescroll-uni.js"],"names":["MeScroll","options","me","version","isDownScrolling","isUpScrolling","hasDownCallback","down","callback","initDownScroll","initUpScroll","setTimeout","optDown","use","auto","autoShowLoading","triggerDownScroll","optUp","isUpAutoLoad","triggerUpScroll","prototype","extendDownScroll","extend","isLock","offset","startTop","fps","supply","inOffsetRate","outOffsetRate","bottomOffset","minAngle","textInOffset","textOutOffset","textLoading","inited","inOffset","outOffset","onMoving","beforeLoading","showLoading","afterLoading","endDownScroll","mescroll","resetUpScroll","extendUpScroll","isBoth","isBounce","page","num","size","time","noMoreSize","textNoMore","showNoMore","hideUpScroll","toTop","src","duration","btnClick","onShow","empty","icon","tip","btnText","onScroll","userOption","defaultOption","key","def","downHight","touchstartEvent","e","startPoint","getPoint","getScrollTop","lastPoint","maxTouchmoveY","getBodyHeight","inTouchend","touchmoveEvent","t","Date","getTime","moveTime","moveTimeDiff","scrollTop","curPoint","moveY","y","x","Math","abs","z","sqrt","angle","asin","PI","touchendEvent","preventDefault","diff","movetype","isMoveDown","round","rate","isScrollUp","touches","pageX","pageY","changedTouches","clientX","clientY","showDownScroll","endScroll","delay","lockDownScroll","up","setBounce","hasNext","startNum","scroll","setScrollTop","setScrollHeight","scrollHeight","preScrollY","showTopBtn","hideTopBtn","isCheck","canUp","getScrollBottom","showUpScroll","endUpScroll","isShowNoMore","isShowLoading","prePageNum","prePageTime","removeEmpty","setPageNum","setPageSize","endByPage","dataSize","totalPage","systime","endSuccess","endBySize","totalSize","loadSize","pageNum","pageSize","showEmpty","allDataSize","endErr","topBtnShow","scrollTo","myScrollTo","resetScrollTo","getScrollHeight","getClientHeight","getStep","star","end","count","step","i","timer","setInterval","clearInterval","isReal","h","clientHeight","setClientHeight","bodyHeight","setBodyHeight","cancelable","defaultPrevented","uniPageDom","document","getElementsByTagName","setAttribute","window","isSetBounce","bounceTouchmove","el","target","isPrevent","body","tagName","getAttribute","cls","classList","contains","curX","curY","preWinX","preWinY","parentNode","addEventListener","passive","removeEventListener"],"mappings":"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","sourcesContent":["/* mescroll-uni\n * version 1.1.5\n * 2019-07-25 wenju\n * https://github.com/leoxiaoge/mescroll\n */\n\nexport default function MeScroll(options) {\n\tlet me = this;\n\tme.version = '1.1.5'; // mescroll版本号\n\tme.options = options || {}; // 配置\n\n\tme.isDownScrolling = false; // 是否在执行下拉刷新的回调\n\tme.isUpScrolling = false; // 是否在执行上拉加载的回调\n\tlet hasDownCallback = me.options.down && me.options.down.callback; // 是否配置了down的callback\n\n\t// 初始化下拉刷新\n\tme.initDownScroll();\n\t// 初始化上拉加载,则初始化\n\tme.initUpScroll();\n\n\t// 自动加载\n\tsetTimeout(function() { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n\t\t// 自动触发下拉刷新 (只有配置了down的callback才自动触发下拉刷新)\n\t\tif (me.optDown.use && me.optDown.auto && hasDownCallback) {\n\t\t\tif (me.optDown.autoShowLoading) {\n\t\t\t\tme.triggerDownScroll(); // 显示下拉进度,执行下拉回调\n\t\t\t} else {\n\t\t\t\tme.optDown.callback && me.optDown.callback(me); // 不显示下拉进度,直接执行下拉回调\n\t\t\t}\n\t\t}\n\t\t// 自动触发上拉加载\n\t\tme.optUp.use && me.optUp.auto && !me.isUpAutoLoad && me.triggerUpScroll();\n\t}, 30); // 需让me.optDown.inited和me.optUp.inited先执行\n}\n\n/* 配置参数:下拉刷新 */\nMeScroll.prototype.extendDownScroll = function(optDown) {\n\t// 下拉刷新的配置\n\tMeScroll.extend(optDown, {\n\t\tuse: true, // 是否启用下拉刷新; 默认true\n\t\tauto: true, // 是否在初始化完毕之后自动执行下拉刷新的回调; 默认true\n\t\tautoShowLoading: false, // 如果设置auto=true(在初始化完毕之后自动执行下拉刷新的回调),那么是否显示下拉刷新的进度; 默认false\n\t\tisLock: false, // 是否锁定下拉刷新,默认false;\n\t\toffset: 80, // 在列表顶部,下拉大于80px,松手即可触发下拉刷新的回调\n\t\tstartTop: 100, // scroll-view滚动到顶部时,此时的scroll-top不一定为0, 此值用于控制最大的误差\n\t\tfps: 40, // 下拉节流 (值越大每秒刷新频率越高)\n\t\tsupply: 200, // 补帧动画的过渡时长 (只对android小程序生效,用于解决android小程序下拉卡顿的问题)\n\t\tinOffsetRate: 1, // 在列表顶部,下拉的距离小于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\n\t\toutOffsetRate: 0.2, // 在列表顶部,下拉的距离大于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\n\t\tbottomOffset: 20, // 当手指touchmove位置在距离body底部20px范围内的时候结束上拉刷新,避免Webview嵌套导致touchend事件不执行\n\t\tminAngle: 45, // 向下滑动最少偏移的角度,取值区间  [0,90];默认45度,即向下滑动的角度大于45度则触发下拉;而小于45度,将不触发下拉,避免与左右滑动的轮播等组件冲突;\n\t\ttextInOffset: '下拉刷新', // 下拉的距离在offset范围内的提示文本\n\t\ttextOutOffset: '释放更新', // 下拉的距离大于offset范围的提示文本\n\t\ttextLoading: '加载中 ...', // 加载中的提示文本\n\t\tinited: null, // 下拉刷新初始化完毕的回调\n\t\tinOffset: null, // 下拉的距离进入offset范围内那一刻的回调\n\t\toutOffset: null, // 下拉的距离大于offset那一刻的回调\n\t\tonMoving: null, // 下拉过程中的回调,滑动过程一直在执行; rate下拉区域当前高度与指定距离的比值(inOffset: rate<1; outOffset: rate>=1); downHight当前下拉区域的高度\n\t\tbeforeLoading: null, // 准备触发下拉刷新的回调: 如果return true,将不触发showLoading和callback回调; 常用来完全自定义下拉刷新, 参考案例【淘宝 v6.8.0】\n\t\tshowLoading: null, // 显示下拉刷新进度的回调\n\t\tafterLoading: null, // 准备结束下拉的回调. 返回结束下拉的延时执行时间,默认0ms; 常用于结束下拉之前再显示另外一小段动画,才去隐藏下拉刷新的场景, 参考案例【dotJump】\n\t\tendDownScroll: null, // 结束下拉刷新的回调\n\t\tcallback: function(mescroll) {\n\t\t\t// 下拉刷新的回调;默认重置上拉加载列表为第一页\n\t\t\tmescroll.resetUpScroll();\n\t\t}\n\t})\n}\n\n/* 配置参数:上拉加载 */\nMeScroll.prototype.extendUpScroll = function(optUp) {\n\t// 上拉加载的配置\n\tMeScroll.extend(optUp, {\n\t\tuse: true, // 是否启用上拉加载; 默认true\n\t\tauto: true, // 是否在初始化完毕之后自动执行上拉加载的回调; 默认true\n\t\tisLock: false, // 是否锁定上拉加载,默认false;\n\t\tisBoth: true, // 上拉加载时,如果滑动到列表顶部是否可以同时触发下拉刷新;默认true,两者可同时触发;\n\t\tisBounce: false, // 默认禁止橡皮筋的回弹效果, 必读事项: http://www.mescroll.com/qa.html?v=190725#q25\n\t\tcallback: null, // 上拉加载的回调;function(page,mescroll){ }\n\t\tpage: {\n\t\t\tnum: 0, // 当前页码,默认0,回调之前会加1,即callback(page)会从1开始\n\t\t\tsize: 10, // 每页数据的数量\n\t\t\ttime: null // 加载第一页数据服务器返回的时间; 防止用户翻页时,后台新增了数据从而导致下一页数据重复;\n\t\t},\n\t\tnoMoreSize: 5, // 如果列表已无数据,可设置列表的总数量要大于等于5条才显示无更多数据;避免列表数据过少(比如只有一条数据),显示无更多数据会不好看\n\t\toffset: 80, // 距底部多远时,触发upCallback\n\t\ttextLoading: '加载中 ...', // 加载中的提示文本\n\t\ttextNoMore: '-- END --', // 没有更多数据的提示文本\n\t\tinited: null, // 初始化完毕的回调\n\t\tshowLoading: null, // 显示加载中的回调\n\t\tshowNoMore: null, // 显示无更多数据的回调\n\t\thideUpScroll: null, // 隐藏上拉加载的回调\n\t\ttoTop: {\n\t\t\t// 回到顶部按钮,需配置src才显示\n\t\t\tsrc: null, // 图片路径,默认null (建议写成网络图,不必考虑相对路径)\n\t\t\toffset: 1000, // 列表滚动多少距离才显示回到顶部按钮,默认1000\n\t\t\tduration: 300, // 回到顶部的动画时长,默认300ms\n\t\t\tbtnClick: null, // 点击按钮的回调\n\t\t\tonShow: null // 是否显示的回调\n\t\t},\n\t\tempty: {\n\t\t\tuse: true, // 是否显示空布局\n\t\t\ticon: null, // 图标路径\n\t\t\ttip: '~ 暂无相关数据 ~', // 提示\n\t\t\tbtnText: '', // 按钮\n\t\t\tbtnClick: null, // 点击按钮的回调\n\t\t\tonShow: null // 是否显示的回调\n\t\t},\n\t\tonScroll: false // 是否监听滚动事件\n\t})\n}\n\n/* 配置参数 */\nMeScroll.extend = function(userOption, defaultOption) {\n\tif (!userOption) return defaultOption;\n\tfor (let key in defaultOption) {\n\t\tif (userOption[key] == null) {\n\t\t\tlet def = defaultOption[key];\n\t\t\tif (def != null && typeof def === 'object') {\n\t\t\t\tuserOption[key] = MeScroll.extend({}, def); // 深度匹配\n\t\t\t} else {\n\t\t\t\tuserOption[key] = def;\n\t\t\t}\n\t\t} else if (typeof userOption[key] === 'object') {\n\t\t\tMeScroll.extend(userOption[key], defaultOption[key]); // 深度匹配\n\t\t}\n\t}\n\treturn userOption;\n}\n\n/* -------初始化下拉刷新------- */\nMeScroll.prototype.initDownScroll = function() {\n\tlet me = this;\n\t// 配置参数\n\tme.optDown = me.options.down || {};\n\tme.extendDownScroll(me.optDown);\n\n\tme.downHight = 0; // 下拉区域的高度\n\n\t// 在页面中加入下拉布局\n\tif (me.optDown.use && me.optDown.inited) {\n\t\t// 初始化完毕的回调\n\t\tsetTimeout(function() { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n\t\t\tme.optDown.inited(me);\n\t\t}, 0)\n\t}\n}\n\n/* 列表touchstart事件 */\nMeScroll.prototype.touchstartEvent = function(e) {\n\tif (!this.optDown.use) return;\n\n\tthis.startPoint = this.getPoint(e); // 记录起点\n\tthis.startTop = this.getScrollTop(); // 记录此时的滚动条位置\n\tthis.lastPoint = this.startPoint; // 重置上次move的点\n\tthis.maxTouchmoveY = this.getBodyHeight() - this.optDown.bottomOffset; // 手指触摸的最大范围(写在touchstart避免body获取高度为0的情况)\n\tthis.inTouchend = false; // 标记不是touchend\n}\n\n/* 列表touchmove事件 */\nMeScroll.prototype.touchmoveEvent = function(e) {\n\tif (!this.optDown.use) return;\n\tif (!this.startPoint) return;\n\tlet me = this;\n\n\t// 节流\n\tlet t = new Date().getTime();\n\tif (me.moveTime && t - me.moveTime < me.moveTimeDiff) { // 小于节流时间,则不处理\n\t\treturn;\n\t} else {\n\t\tme.moveTime = t\n\t\tme.moveTimeDiff = 1000 / me.optDown.fps\n\t}\n\n\tlet scrollTop = me.getScrollTop(); // 当前滚动条的距离\n\tlet curPoint = me.getPoint(e); // 当前点\n\n\tlet moveY = curPoint.y - me.startPoint.y; // 和起点比,移动的距离,大于0向下拉,小于0向上拉\n\n\t// (向下拉&&在顶部) scroll-view在滚动时不会触发touchmove,当触顶/底/左/右时,才会触发touchmove\n\t// scroll-view滚动到顶部时,scrollTop不一定为0; 在iOS的APP中scrollTop可能为负数,不一定和startTop相等\n\tif (moveY > 0 && (scrollTop <= 0 || (scrollTop <= me.optDown.startTop && scrollTop === me.startTop))) {\n\t\t// 可下拉的条件\n\t\tif (me.optDown.use && !me.inTouchend && !me.isDownScrolling && !me.optDown.isLock && (!me.isUpScrolling || (me.isUpScrolling &&\n\t\t\t\tme.optUp.isBoth))) {\n\n\t\t\t// 下拉的角度是否在配置的范围内\n\t\t\tlet x = Math.abs(me.lastPoint.x - curPoint.x);\n\t\t\tlet y = Math.abs(me.lastPoint.y - curPoint.y);\n\t\t\tlet z = Math.sqrt(x * x + y * y);\n\t\t\tif (z !== 0) {\n\t\t\t\tlet angle = Math.asin(y / z) / Math.PI * 180; // 两点之间的角度,区间 [0,90]\n\t\t\t\tif (angle < me.optDown.minAngle) return; // 如果小于配置的角度,则不往下执行下拉刷新\n\t\t\t}\n\n\t\t\t// 如果手指的位置超过配置的距离,则提前结束下拉,避免Webview嵌套导致touchend无法触发\n\t\t\tif (me.maxTouchmoveY > 0 && curPoint.y >= me.maxTouchmoveY) {\n\t\t\t\tme.inTouchend = true; // 标记执行touchend\n\t\t\t\tme.touchendEvent(); // 提前触发touchend\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tme.preventDefault(e); // 阻止默认事件\n\n\t\t\tlet diff = curPoint.y - me.lastPoint.y; // 和上次比,移动的距离 (大于0向下,小于0向上)\n\n\t\t\t// 下拉距离  < 指定距离\n\t\t\tif (me.downHight < me.optDown.offset) {\n\t\t\t\tif (me.movetype !== 1) {\n\t\t\t\t\tme.movetype = 1; // 加入标记,保证只执行一次\n\t\t\t\t\tme.optDown.inOffset && me.optDown.inOffset(me); // 进入指定距离范围内那一刻的回调,只执行一次\n\t\t\t\t\tme.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\n\t\t\t\t}\n\t\t\t\tme.downHight += diff * me.optDown.inOffsetRate; // 越往下,高度变化越小\n\n\t\t\t\t// 指定距离  <= 下拉距离\n\t\t\t} else {\n\t\t\t\tif (me.movetype !== 2) {\n\t\t\t\t\tme.movetype = 2; // 加入标记,保证只执行一次\n\t\t\t\t\tme.optDown.outOffset && me.optDown.outOffset(me); // 下拉超过指定距离那一刻的回调,只执行一次\n\t\t\t\t\tme.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\n\t\t\t\t}\n\t\t\t\tif (diff > 0) { // 向下拉\n\t\t\t\t\tme.downHight += Math.round(diff * me.optDown.outOffsetRate); // 越往下,高度变化越小\n\t\t\t\t} else { // 向上收\n\t\t\t\t\tme.downHight += diff; // 向上收回高度,则向上滑多少收多少高度\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet rate = me.downHight / me.optDown.offset; // 下拉区域当前高度与指定距离的比值\n\t\t\tme.optDown.onMoving && me.optDown.onMoving(me, rate, me.downHight); // 下拉过程中的回调,一直在执行\n\t\t}\n\t}\n\n\tme.lastPoint = curPoint; // 记录本次移动的点\n}\n\n/* 列表touchend事件 */\nMeScroll.prototype.touchendEvent = function(e) {\n\tif (!this.optDown.use) return;\n\t// 如果下拉区域高度已改变,则需重置回来\n\tif (this.isMoveDown) {\n\t\tif (this.downHight >= this.optDown.offset) {\n\t\t\t// 符合触发刷新的条件\n\t\t\tthis.triggerDownScroll();\n\t\t} else {\n\t\t\t// 不符合的话 则重置\n\t\t\tthis.downHight = 0;\n\t\t\tthis.optDown.endDownScroll && this.optDown.endDownScroll(this);\n\t\t}\n\t\tthis.movetype = 0;\n\t\tthis.isMoveDown = false;\n\t} else if (this.getScrollTop() === this.startTop) { // 到顶/左/右/底的滑动事件\n\t\tlet isScrollUp = this.getPoint(e).y - this.startPoint.y < 0; // 和起点比,移动的距离,大于0向下拉,小于0向上拉\n\t\t// 上滑 && 检查并触发上拉\n\t\tisScrollUp && this.triggerUpScroll(true);\n\t}\n}\n\n/* 根据点击滑动事件获取第一个手指的坐标 */\nMeScroll.prototype.getPoint = function(e) {\n\tif (e.touches && e.touches[0]) {\n\t\treturn {\n\t\t\tx: e.touches[0].pageX,\n\t\t\ty: e.touches[0].pageY\n\t\t}\n\t} else if (e.changedTouches && e.changedTouches[0]) {\n\t\treturn {\n\t\t\tx: e.changedTouches[0].pageX,\n\t\t\ty: e.changedTouches[0].pageY\n\t\t}\n\t} else {\n\t\treturn {\n\t\t\tx: e.clientX,\n\t\t\ty: e.clientY\n\t\t}\n\t}\n}\n\n/* 触发下拉刷新 */\nMeScroll.prototype.triggerDownScroll = function() {\n\tif (this.optDown.beforeLoading && this.optDown.beforeLoading(this)) {\n\t\t//return true则处于完全自定义状态\n\t} else {\n\t\tthis.showDownScroll(); // 下拉刷新中...\n\t\tthis.optDown.callback && this.optDown.callback(this); // 执行回调,联网加载数据\n\t}\n}\n\n/* 显示下拉进度布局 */\nMeScroll.prototype.showDownScroll = function() {\n\tthis.isDownScrolling = true; // 标记下拉中\n\tthis.downHight = this.optDown.offset; // 更新下拉区域高度\n\tthis.optDown.showLoading(this, this.downHight); // 下拉刷新中...\n}\n\n/* 结束下拉刷新 */\nMeScroll.prototype.endDownScroll = function() {\n\tlet me = this;\n\t// 结束下拉刷新的方法\n\tlet endScroll = function() {\n\t\tme.downHight = 0;\n\t\tme.isDownScrolling = false;\n\t\tme.optDown.endDownScroll && me.optDown.endDownScroll(me);\n\t}\n\t// 结束下拉刷新时的回调\n\tlet delay = 0;\n\tif (me.optDown.afterLoading) delay = me.optDown.afterLoading(me); // 结束下拉刷新的延时,单位ms\n\tif (typeof delay === 'number' && delay > 0) {\n\t\tsetTimeout(endScroll, delay);\n\t} else {\n\t\tendScroll();\n\t}\n}\n\n/* 锁定下拉刷新:isLock=ture,null锁定;isLock=false解锁 */\nMeScroll.prototype.lockDownScroll = function(isLock) {\n\tif (isLock == null) isLock = true;\n\tthis.optDown.isLock = isLock;\n}\n\n/* -------初始化上拉加载------- */\nMeScroll.prototype.initUpScroll = function() {\n\tlet me = this;\n\t// 配置参数\n\tme.optUp = me.options.up || {\n\t\tuse: false\n\t};\n\tme.extendUpScroll(me.optUp);\n\n\tif (!me.optUp.isBounce) me.setBounce(false); // 不允许bounce时,需禁止window的touchmove事件\n\n\tif (me.optUp.use === false) return; // 配置不使用上拉加载时,则不初始化上拉布局\n\tme.optUp.hasNext = true; // 如果使用上拉,则默认有下一页\n\tme.startNum = me.optUp.page.num + 1; // 记录page开始的页码\n\n\t// 初始化完毕的回调\n\tif (me.optUp.inited) {\n\t\tsetTimeout(function() { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n\t\t\tme.optUp.inited(me);\n\t\t}, 0)\n\t}\n}\n\n/*列表滚动事件*/\nMeScroll.prototype.scroll = function(e, onScroll) {\n\t// 更新滚动条的位置\n\tthis.setScrollTop(e.scrollTop);\n\t// 更新滚动内容高度\n\tthis.setScrollHeight(e.scrollHeight);\n\n\t// 向上滑还是向下滑动\n\tif (this.preScrollY == null) this.preScrollY = 0;\n\tthis.isScrollUp = e.scrollTop - this.preScrollY > 0;\n\tthis.preScrollY = e.scrollTop;\n\n\t// 上滑 && 检查并触发上拉\n\tthis.isScrollUp && this.triggerUpScroll(true);\n\n\t// 顶部按钮的显示隐藏\n\tif (e.scrollTop >= this.optUp.toTop.offset) {\n\t\tthis.showTopBtn();\n\t} else {\n\t\tthis.hideTopBtn();\n\t}\n\n\t// 滑动监听\n\tthis.optUp.onScroll && onScroll && onScroll()\n}\n\n/* 触发上拉加载 */\nMeScroll.prototype.triggerUpScroll = function(isCheck) {\n\tif (!this.isUpScrolling && this.optUp.use && this.optUp.callback) {\n\t\t// 是否校验在底部; 默认不校验\n\t\tif (isCheck === true) {\n\t\t\tlet canUp = false;\n\t\t\t// 还有下一页 && 没有锁定 && (不在下拉中 || 支持同时上下拉)\n\t\t\tif (this.optUp.hasNext && !this.optUp.isLock && !this.isDownScrolling) {\n\t\t\t\tif (this.getScrollBottom() <= this.optUp.offset) { // 到底部\n\t\t\t\t\tcanUp = true; // 标记可上拉\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (canUp === false) return;\n\t\t}\n\t\tthis.showUpScroll(); // 上拉加载中...\n\t\tthis.optUp.page.num++; // 预先加一页,如果失败则减回\n\t\tthis.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\n\t\tthis.num = this.optUp.page.num; // 把最新的页数赋值在mescroll上,避免对page的影响\n\t\tthis.size = this.optUp.page.size; // 把最新的页码赋值在mescroll上,避免对page的影响\n\t\tthis.time = this.optUp.page.time; // 把最新的页码赋值在mescroll上,避免对page的影响\n\t\tthis.optUp.callback(this); // 执行回调,联网加载数据\n\t}\n}\n\n/* 显示上拉加载中 */\nMeScroll.prototype.showUpScroll = function() {\n\tthis.isUpScrolling = true; // 标记上拉加载中\n\tthis.optUp.showLoading && this.optUp.showLoading(this); // 回调\n}\n\n/* 显示上拉无更多数据 */\nMeScroll.prototype.showNoMore = function() {\n\tthis.optUp.hasNext = false; // 标记无更多数据\n\tthis.optUp.showNoMore && this.optUp.showNoMore(this); // 回调\n}\n\n/* 隐藏上拉区域**/\nMeScroll.prototype.hideUpScroll = function() {\n\tthis.optUp.hideUpScroll && this.optUp.hideUpScroll(this); // 回调\n}\n\n/* 结束上拉加载 */\nMeScroll.prototype.endUpScroll = function(isShowNoMore) {\n\tif (isShowNoMore != null) { // isShowNoMore=null,不处理下拉状态,下拉刷新的时候调用\n\t\tif (isShowNoMore) {\n\t\t\tthis.showNoMore(); // isShowNoMore=true,显示无更多数据\n\t\t} else {\n\t\t\tthis.hideUpScroll(); // isShowNoMore=false,隐藏上拉加载\n\t\t}\n\t}\n\tthis.isUpScrolling = false; // 标记结束上拉加载\n}\n\n/* 重置上拉加载列表为第一页\n *isShowLoading 是否显示进度布局;\n * 1.默认null,不传参,则显示上拉加载的进度布局\n * 2.传参true, 则显示下拉刷新的进度布局\n * 3.传参false,则不显示上拉和下拉的进度 (常用于静默更新列表数据)\n */\nMeScroll.prototype.resetUpScroll = function(isShowLoading) {\n\tif (this.optUp && this.optUp.use) {\n\t\tlet page = this.optUp.page;\n\t\tthis.prePageNum = page.num; // 缓存重置前的页码,加载失败可退回\n\t\tthis.prePageTime = page.time; // 缓存重置前的时间,加载失败可退回\n\t\tpage.num = this.startNum; // 重置为第一页\n\t\tpage.time = null; // 重置时间为空\n\t\tif (!this.isDownScrolling && isShowLoading !== false) { // 如果不是下拉刷新触发的resetUpScroll并且不配置列表静默更新,则显示进度;\n\t\t\tif (isShowLoading == null) {\n\t\t\t\tthis.removeEmpty(); // 移除空布局\n\t\t\t\tthis.showUpScroll(); // 不传参,默认显示上拉加载的进度布局\n\t\t\t} else {\n\t\t\t\tthis.showDownScroll(); // 传true,显示下拉刷新的进度布局,不清空列表\n\t\t\t}\n\t\t}\n\t\tthis.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\n\t\tthis.num = page.num; // 把最新的页数赋值在mescroll上,避免对page的影响\n\t\tthis.size = page.size; // 把最新的页码赋值在mescroll上,避免对page的影响\n\t\tthis.time = page.time; // 把最新的页码赋值在mescroll上,避免对page的影响\n\t\tthis.optUp.callback && this.optUp.callback(this); // 执行上拉回调\n\t}\n}\n\n/* 设置page.num的值 */\nMeScroll.prototype.setPageNum = function(num) {\n\tthis.optUp.page.num = num - 1;\n}\n\n/* 设置page.size的值 */\nMeScroll.prototype.setPageSize = function(size) {\n\tthis.optUp.page.size = size;\n}\n\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据量(必传)\n * totalPage: 总页数(必传)\n * systime: 服务器时间 (可空)\n */\nMeScroll.prototype.endByPage = function(dataSize, totalPage, systime) {\n\tlet hasNext;\n\tif (this.optUp.use && totalPage != null) hasNext = this.optUp.page.num < totalPage; // 是否还有下一页\n\tthis.endSuccess(dataSize, hasNext, systime);\n}\n\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据量(必传)\n * totalSize: 列表所有数据总数量(必传)\n * systime: 服务器时间 (可空)\n */\nMeScroll.prototype.endBySize = function(dataSize, totalSize, systime) {\n\tlet hasNext;\n\tif (this.optUp.use && totalSize != null) {\n\t\tlet loadSize = (this.optUp.page.num - 1) * this.optUp.page.size + dataSize; // 已加载的数据总数\n\t\thasNext = loadSize < totalSize; // 是否还有下一页\n\t}\n\tthis.endSuccess(dataSize, hasNext, systime);\n}\n\n/* 联网回调成功,结束下拉刷新和上拉加载\n * dataSize: 当前页的数据个数(不是所有页的数据总和),用于上拉加载判断是否还有下一页.如果不传,则会判断还有下一页\n * hasNext: 是否还有下一页,布尔类型;用来解决这个小问题:比如列表共有20条数据,每页加载10条,共2页.如果只根据dataSize判断,则需翻到第三页才会知道无更多数据,如果传了hasNext,则翻到第二页即可显示无更多数据.\n * systime: 服务器时间(可空);用来解决这个小问题:当准备翻下一页时,数据库新增了几条记录,此时翻下一页,前面的几条数据会和上一页的重复;这里传入了systime,那么upCallback的page.time就会有值,把page.time传给服务器,让后台过滤新加入的那几条记录\n */\nMeScroll.prototype.endSuccess = function(dataSize, hasNext, systime) {\n\tlet me = this;\n\t// 结束下拉刷新\n\tif (me.isDownScrolling) me.endDownScroll();\n\n\t// 结束上拉加载\n\tif (me.optUp.use) {\n\t\tlet isShowNoMore; // 是否已无更多数据\n\t\tif (dataSize != null) {\n\t\t\tlet pageNum = me.optUp.page.num; // 当前页码\n\t\t\tlet pageSize = me.optUp.page.size; // 每页长度\n\t\t\t// 如果是第一页\n\t\t\tif (pageNum === 1) {\n\t\t\t\tif (systime) me.optUp.page.time = systime; // 设置加载列表数据第一页的时间\n\t\t\t}\n\t\t\tif (dataSize < pageSize || hasNext === false) {\n\t\t\t\t// 返回的数据不满一页时,则说明已无更多数据\n\t\t\t\tme.optUp.hasNext = false;\n\t\t\t\tif (dataSize === 0 && pageNum === 1) {\n\t\t\t\t\t// 如果第一页无任何数据且配置了空布局\n\t\t\t\t\tisShowNoMore = false;\n\t\t\t\t\tme.showEmpty();\n\t\t\t\t} else {\n\t\t\t\t\t// 总列表数少于配置的数量,则不显示无更多数据\n\t\t\t\t\tlet allDataSize = (pageNum - 1) * pageSize + dataSize;\n\t\t\t\t\tif (allDataSize < me.optUp.noMoreSize) {\n\t\t\t\t\t\tisShowNoMore = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisShowNoMore = true;\n\t\t\t\t\t}\n\t\t\t\t\tme.removeEmpty(); // 移除空布局\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 还有下一页\n\t\t\t\tisShowNoMore = false;\n\t\t\t\tme.optUp.hasNext = true;\n\t\t\t\tme.removeEmpty(); // 移除空布局\n\t\t\t}\n\t\t}\n\n\t\t// 隐藏上拉\n\t\tme.endUpScroll(isShowNoMore);\n\t}\n}\n\n/* 回调失败,结束下拉刷新和上拉加载 */\nMeScroll.prototype.endErr = function() {\n\t// 结束下拉,回调失败重置回原来的页码和时间\n\tif (this.isDownScrolling) {\n\t\tlet page = this.optUp.page;\n\t\tif (page && this.prePageNum) {\n\t\t\tpage.num = this.prePageNum;\n\t\t\tpage.time = this.prePageTime;\n\t\t}\n\t\tthis.endDownScroll();\n\t}\n\t// 结束上拉,回调失败重置回原来的页码\n\tif (this.isUpScrolling) {\n\t\tthis.optUp.page.num--;\n\t\tthis.endUpScroll(false);\n\t}\n}\n\n/* 显示空布局 */\nMeScroll.prototype.showEmpty = function() {\n\tthis.optUp.empty.use && this.optUp.empty.onShow && this.optUp.empty.onShow(true)\n}\n\n/* 移除空布局 */\nMeScroll.prototype.removeEmpty = function() {\n\tthis.optUp.empty.use && this.optUp.empty.onShow && this.optUp.empty.onShow(false)\n}\n\n/* 显示回到顶部的按钮 */\nMeScroll.prototype.showTopBtn = function() {\n\tif (!this.topBtnShow) {\n\t\tthis.topBtnShow = true;\n\t\tthis.optUp.toTop.onShow && this.optUp.toTop.onShow(true);\n\t}\n}\n\n/* 隐藏回到顶部的按钮 */\nMeScroll.prototype.hideTopBtn = function() {\n\tif (this.topBtnShow) {\n\t\tthis.topBtnShow = false;\n\t\tthis.optUp.toTop.onShow && this.optUp.toTop.onShow(false);\n\t}\n}\n\n/* 获取滚动条的位置 */\nMeScroll.prototype.getScrollTop = function() {\n\treturn this.scrollTop || 0\n}\n\n/* 记录滚动条的位置 */\nMeScroll.prototype.setScrollTop = function(y) {\n\tthis.scrollTop = y;\n}\n\n/* 滚动到指定位置 */\nMeScroll.prototype.scrollTo = function(y, t) {\n\tthis.myScrollTo && this.myScrollTo(y, t) // scrollview需自定义回到顶部方法\n}\n\n/* 自定义scrollTo */\nMeScroll.prototype.resetScrollTo = function(myScrollTo) {\n\tthis.myScrollTo = myScrollTo\n}\n\n/* 滚动条到底部的距离 */\nMeScroll.prototype.getScrollBottom = function() {\n\treturn this.getScrollHeight() - this.getClientHeight() - this.getScrollTop()\n}\n\n/* 计步器\n star: 开始值\n end: 结束值\n callback(step,timer): 回调step值,计步器timer,可自行通过window.clearInterval(timer)结束计步器;\n t: 计步时长,传0则直接回调end值;不传则默认300ms\n rate: 周期;不传则默认30ms计步一次\n * */\nMeScroll.prototype.getStep = function(star, end, callback, t, rate) {\n\tlet diff = end - star; // 差值\n\tif (t === 0 || diff === 0) {\n\t\tcallback && callback(end);\n\t\treturn;\n\t}\n\tt = t || 300; // 时长 300ms\n\trate = rate || 30; // 周期 30ms\n\tlet count = t / rate; // 次数\n\tlet step = diff / count; // 步长\n\tlet i = 0; // 计数\n\tlet timer = setInterval(function() {\n\t\tif (i < count - 1) {\n\t\t\tstar += step;\n\t\t\tcallback && callback(star, timer);\n\t\t\ti++;\n\t\t} else {\n\t\t\tcallback && callback(end, timer); // 最后一次直接设置end,避免计算误差\n\t\t\tclearInterval(timer);\n\t\t}\n\t}, rate);\n}\n\n/* 滚动容器的高度 */\nMeScroll.prototype.getClientHeight = function(isReal) {\n\tlet h = this.clientHeight || 0\n\tif (h === 0 && isReal !== true) { // 未获取到容器的高度,可临时取body的高度 (可能会有误差)\n\t\th = this.getBodyHeight()\n\t}\n\treturn h\n}\nMeScroll.prototype.setClientHeight = function(h) {\n\tthis.clientHeight = h;\n}\n\n/* 滚动内容的高度 */\nMeScroll.prototype.getScrollHeight = function() {\n\treturn this.scrollHeight || 0;\n}\nMeScroll.prototype.setScrollHeight = function(h) {\n\tthis.scrollHeight = h;\n}\n\n/* body的高度 */\nMeScroll.prototype.getBodyHeight = function() {\n\treturn this.bodyHeight || 0;\n}\nMeScroll.prototype.setBodyHeight = function(h) {\n\tthis.bodyHeight = h;\n}\n\n/* 阻止浏览器默认滚动事件 */\nMeScroll.prototype.preventDefault = function(e) {\n\t// 小程序不支持e.preventDefault\n\t// app的bounce只能通过配置pages.json的style.app-plus.bounce为\"none\"来禁止\n\t// cancelable:是否可以被禁用; defaultPrevented:是否已经被禁用\n\tif (e && e.cancelable && !e.defaultPrevented) e.preventDefault()\n}\n\n/* 是否允许下拉回弹(橡皮筋效果); true或null为允许; false禁止bounce */\nMeScroll.prototype.setBounce = function(isBounce) {\n\n\tif (isBounce === false) {\n\t\tthis.optUp.isBounce = false; // 禁止\n\t\t// 标记当前页使用了mescroll (需延时,确保page已切换)\n\t\tsetTimeout(function() {\n\t\t\tlet uniPageDom = document.getElementsByTagName('uni-page')[0];\n\t\t\tuniPageDom && uniPageDom.setAttribute('use_mescroll', true)\n\t\t}, 30);\n\t\t// 避免重复添加事件\n\t\tif (window.isSetBounce) return;\n\t\twindow.isSetBounce = true;\n\t\t// 需禁止window的touchmove事件才能有效的阻止bounce\n\t\twindow.bounceTouchmove = function(e) {\n\t\t\tlet el = e.target;\n\t\t\t// 当前touch的元素及父元素是否要拦截touchmove事件\n\t\t\tlet isPrevent = true;\n\t\t\twhile (el !== document.body && el !== document) {\n\t\t\t\tif (el.tagName === 'UNI-PAGE') { // 只扫描当前页\n\t\t\t\t\tif (!el.getAttribute('use_mescroll')) {\n\t\t\t\t\t\tisPrevent = false; // 如果当前页没有使用mescroll,则不阻止\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet cls = el.classList;\n\t\t\t\tif (cls) {\n\t\t\t\t\tif (cls.contains('mescroll-touch')) { // 采用scroll-view 此处不能过滤mescroll-uni,否则下拉仍然有回弹\n\t\t\t\t\t\tisPrevent = false; // mescroll-touch无需拦截touchmove事件\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (cls.contains('mescroll-touch-x') || cls.contains('mescroll-touch-y')) {\n\t\t\t\t\t\t// 如果配置了水平或者垂直滑动\n\t\t\t\t\t\tlet curX = e.touches ? e.touches[0].pageX : e.clientX; // 当前第一个手指距离列表顶部的距离x\n\t\t\t\t\t\tlet curY = e.touches ? e.touches[0].pageY : e.clientY; // 当前第一个手指距离列表顶部的距离y\n\t\t\t\t\t\tif (!this.preWinX) this.preWinX = curX; // 设置上次移动的距离x\n\t\t\t\t\t\tif (!this.preWinY) this.preWinY = curY; // 设置上次移动的距离y\n\t\t\t\t\t\t// 计算两点之间的角度\n\t\t\t\t\t\tlet x = Math.abs(this.preWinX - curX);\n\t\t\t\t\t\tlet y = Math.abs(this.preWinY - curY);\n\t\t\t\t\t\tlet z = Math.sqrt(x * x + y * y);\n\t\t\t\t\t\tthis.preWinX = curX; // 记录本次curX的值\n\t\t\t\t\t\tthis.preWinY = curY; // 记录本次curY的值\n\t\t\t\t\t\tif (z !== 0) {\n\t\t\t\t\t\t\tlet angle = Math.asin(y / z) / Math.PI * 180; // 角度区间 [0,90]\n\t\t\t\t\t\t\tif ((angle <= 45 && cls.contains('mescroll-touch-x')) || (angle > 45 && cls.contains('mescroll-touch-y'))) {\n\t\t\t\t\t\t\t\tisPrevent = false; // 水平滑动或者垂直滑动,不拦截touchmove事件\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tel = el.parentNode; // 继续检查其父元素\n\t\t\t}\n\t\t\t// 拦截touchmove事件:是否可以被禁用&&是否已经被禁用 (这里不使用me.preventDefault(e)的方法,因为某些情况下会报找不到方法的异常)\n\t\t\tif (isPrevent && e.cancelable && !e.defaultPrevented && typeof e.preventDefault === \"function\") e.preventDefault();\n\t\t}\n\t\twindow.addEventListener('touchmove', window.bounceTouchmove, {\n\t\t\tpassive: false\n\t\t});\n\t} else {\n\t\tthis.optUp.isBounce = true; // 允许\n\t\tif (window.bounceTouchmove) {\n\t\t\twindow.removeEventListener('touchmove', window.bounceTouchmove);\n\t\t\twindow.bounceTouchmove = null;\n\t\t\twindow.isSetBounce = false;\n\t\t}\n\t}\n\n}\n"]}]}